
================================================================================
File: .\codebase_contents.txt
================================================================================




================================================================================
File: .\codebase_reader.py
================================================================================

import os

def read_codebase():
    # Output file path
    output_file = 'codebase_contents.txt'
    
    # List of extensions to ignore
    ignore_extensions = {'.class', '.jar', '.git', '.idea', 'target', '__pycache__', '.iml'}
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk('.'):
            # Skip ignored directories
            dirs[:] = [d for d in dirs if d not in ignore_extensions]
            
            for file in files:
                # Skip files with ignored extensions
                if any(ignore in file for ignore in ignore_extensions):
                    continue
                    
                file_path = os.path.join(root, file)
                try:
                    # Try to read the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        
                    # Write file path and content to output file
                    outfile.write(f'\n{"="*80}\n')
                    outfile.write(f'File: {file_path}\n')
                    outfile.write(f'{"="*80}\n\n')
                    outfile.write(content)
                    outfile.write('\n\n')
                    print(f'Successfully processed: {file_path}')
                except Exception as e:
                    print(f'Error processing {file_path}: {str(e)}')

if __name__ == '__main__':
    print('Starting to read codebase...')
    read_codebase()
    print('Finished! Check codebase_contents.txt for the output.') 


================================================================================
File: .\pom.xml
================================================================================

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>xyz.arcadiadevs</groupId>
    <artifactId>GensPlus</artifactId>
    <version>1.6.0</version>
    <packaging>jar</packaging>

    <name>GensPlus</name>

    <properties>
        <java.version>17</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.2.4</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

    <repositories>
        <repository>
            <id>spigotmc-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </repository>
        <repository>
            <id>papermc</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </repository>
        <repository>
            <id>jitpack.io</id>
            <url>https://jitpack.io</url>
        </repository>
        <repository>
            <id>placeholderapi</id>
            <url>https://repo.extendedclip.com/content/repositories/placeholderapi/</url>
        </repository>
        <repository>
            <id>iridiumdevelopment</id>
            <url>https://nexus.iridiumdevelopment.net/repository/maven-releases/</url>
        </repository>
        <repository>
            <id>CodeMC</id>
            <url>https://repo.codemc.org/repository/maven-public/</url>
        </repository>
        <repository>
            <id>codemc-repo</id>
            <url>https://repo.codemc.org/repository/maven-public/</url>
        </repository>
        <repository>
            <id>bg-repo</id>
            <url>https://repo.bg-software.com/repository/api/</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>org.spigotmc</groupId>
            <artifactId>spigot-api</artifactId>
            <version>1.20.6-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.10.1</version>
        </dependency>
        <dependency>
            <groupId>org.json</groupId>
            <artifactId>json</artifactId>
            <version>20231013</version>
        </dependency>
        <dependency>
            <groupId>com.github.cryptomorin</groupId>
            <artifactId>XSeries</artifactId>
            <version>11.2.0.1</version>
        </dependency>
        <dependency>
            <groupId>org.jetbrains</groupId>
            <artifactId>annotations</artifactId>
            <version>24.0.1</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>com.github.Marcono1234</groupId>
            <artifactId>gson-record-type-adapter-factory</artifactId>
            <version>v0.3.0</version>
        </dependency>
        <dependency>
            <groupId>com.github.MilkBowl</groupId>
            <artifactId>VaultAPI</artifactId>
            <version>1.7.1</version>
            <scope>provided</scope>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.github.placeholderapi/placeholderapi -->
        <dependency>
            <groupId>com.github.placeholderapi</groupId>
            <artifactId>placeholderapi</artifactId>
            <version>2.11.5</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>com.github.oraxen</groupId>
            <artifactId>oraxen</artifactId>
            <version>1.156.2</version>
            <scope>provided</scope>
            <exclusions>
                <exclusion>
                    <groupId>gs.mclo</groupId>
                    <artifactId>mclogs</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>com.ticxo</groupId>
                    <artifactId>PlayerAnimator</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>me.gabytm.util</groupId>
                    <artifactId>actions-spigot</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>net.kyori</groupId>
                    <artifactId>*</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>com.jeff_media</groupId>
                    <artifactId>*</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>com.github.LoneDev6</groupId>
            <artifactId>api-itemsadder</artifactId>
            <version>3.5.0b</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.iridium</groupId>
            <artifactId>IridiumSkyblock</artifactId>
            <version>LATEST</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>io.github.bananapuncher714</groupId>
            <artifactId>nbteditor</artifactId>
            <version>7.19.7</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>world.bentobox</groupId>
            <artifactId>bentobox</artifactId>
            <version>1.24.1</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>world.bentobox</groupId>
            <artifactId>level</artifactId>
            <version>2.11.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.bgsoftware</groupId>
            <artifactId>SuperiorSkyblockAPI</artifactId>
            <version>2023.2</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.awaitquality</groupId>
            <artifactId>Api</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>com.github.unldenis.holoeasy</groupId>
            <artifactId>holoeasy-core</artifactId>
            <version>3.4.4</version>
        </dependency>

        <!-- For java projects include also the kotlin stdlib -->
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-stdlib</artifactId>
            <version>1.9.21</version>
        </dependency>
    </dependencies>
</project>



================================================================================
File: .\.vscode\settings.json
================================================================================

{
    "java.compile.nullAnalysis.mode": "automatic",
    "java.configuration.updateBuildConfiguration": "interactive"
}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\GensPlus.java
================================================================================

package xyz.arcadiadevs.gensplus;

import com.awaitquality.api.spigot.chat.ChatUtil;
import com.cryptomorin.xseries.XMaterial;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import io.github.bananapuncher714.nbteditor.NBTEditor;
import lombok.Getter;
import marcono1234.gson.recordadapter.RecordTypeAdapterFactory;
import net.milkbowl.vault.economy.Economy;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.RegisteredServiceProvider;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.holoeasy.HoloEasy;
import org.holoeasy.hologram.Hologram;
import org.holoeasy.pool.IHologramPool;
import xyz.arcadiadevs.gensplus.commands.Commands;
import xyz.arcadiadevs.gensplus.commands.CommandsTabCompletion;
import xyz.arcadiadevs.gensplus.commands.SellCommandListener;
import xyz.arcadiadevs.gensplus.events.*;
import xyz.arcadiadevs.gensplus.events.skyblock.Bentobox;
import xyz.arcadiadevs.gensplus.events.skyblock.IridiumSkyblock;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.models.WandData;
import xyz.arcadiadevs.gensplus.models.events.DropEvent;
import xyz.arcadiadevs.gensplus.models.events.Event;
import xyz.arcadiadevs.gensplus.models.events.SellEvent;
import xyz.arcadiadevs.gensplus.models.events.SpeedEvent;
import xyz.arcadiadevs.gensplus.placeholders.PapiHandler;
import xyz.arcadiadevs.gensplus.tasks.CleanupTask;
import xyz.arcadiadevs.gensplus.tasks.DataSaveTask;
import xyz.arcadiadevs.gensplus.tasks.EventLoop;
import xyz.arcadiadevs.gensplus.tasks.SpawnerTask;
import xyz.arcadiadevs.gensplus.utils.HologramsUtil;
import xyz.arcadiadevs.gensplus.utils.ItemUtil;
import xyz.arcadiadevs.gensplus.utils.Metrics;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * The main plugin class for GensPlus.
 */
@SuppressWarnings("UnstableApiUsage")
public final class GensPlus extends JavaPlugin {

  /**
   * Gets the instance of the GensPlus plugin.
   */
  @Getter
  public static GensPlus instance;

  /**
   * Gets the hologram pool instance for hologram management.
   *
   * @implNote Null if holograms are disabled.
   */
  @Getter
  private IHologramPool hologramPool;

  /**
   * Gets the Gson instance used for JSON serialization/deserialization.
   */
  @Getter
  private Gson gson;

  /**
   * Gets the data handler for locations.
   */
  @Getter
  private LocationsData locationsData;

  /**
   * Gets the data handler for wands.
   */
  @Getter
  private WandData wandData;

  /**
   * Gets the data handler for player data.
   */
  @Getter
  private PlayerData playerData;

  /**
   * Gets the data handler for generators.
   */
  @Getter
  private GeneratorsData generatorsData;

  /**
   * Gets the economy plugin instance.
   */
  @Getter
  private Economy econ = null;

  /**
   * Gets the list of events.
   */
  @Getter
  private List<Event> events;

  /**
   * Gets the data save task.
   */
  @Getter
  private DataSaveTask dataSaveTask;

  /**
   * Gets the PAPI handler.
   */
  private PapiHandler papiHandler;

  /**
   * Gets the metrics instance.
   */
  private Metrics metrics;

  @Override
  public void onEnable() {
    instance = this;

    new BukkitRunnable() {
      @Override
      public void run() {

        saveDefaultConfig();

        moveBlockData();

        saveResourceIfNotExists("data/block_data.json", false);
        saveResourceIfNotExists("data/wands_data.json", false);
        saveResourceIfNotExists("data/player_data.json", false);
        saveResourceIfNotExists("messages.yml", false);

        setupEconomy();

        Messages.init();

        gson = new GsonBuilder().registerTypeAdapterFactory(RecordTypeAdapterFactory.DEFAULT)
            .setPrettyPrinting()
            .create();

        generatorsData = loadGeneratorsData();

        locationsData = new LocationsData(loadBlockDataFromJson());

        playerData = new PlayerData(loadPlayerDataFromJson());

        wandData = new WandData(loadWandsDataFromJson());

        events = loadGensPlusEvents();

        metrics = new Metrics(instance, 19293);

        if (getServer().getPluginManager().getPlugin("PlaceHolderAPI") != null) {
          instance.papiHandler = new PapiHandler(instance, locationsData, playerData);
          instance.papiHandler.register();
        }

        // Register tasks
        registerTasks();

        // Load player data in case the plugin gets enabled manually after server start
        loadPlayers();

        // Register events
        loadBukkitEvents();

        // Register commands
        registerCommands();

        // Register tab completion
        registerTabCompletion();

        // Load holograms
        loadHolograms();

        getLogger().info("GensPlus has been enabled.");
      }
    }.runTaskLater(this, 20L);
  }

  @Override
  public void onDisable() {
    // Save data to JSON
    dataSaveTask.saveBlockDataToJson();
    dataSaveTask.saveWandDataToJson();
    dataSaveTask.savePlayerDataToJson();

    // Unregister any listeners or handlers
    if (papiHandler != null) {
      papiHandler.unregister();
    }

    // Unregister bukkit events
    HandlerList.unregisterAll(this);

    Bukkit.getScheduler().cancelTasks(this);

    // Save configuration files
    reloadConfig();

    for (LocationsData.GeneratorLocation location : locationsData.locations()) {
      if (location.getHologram() != null) {
        HologramsUtil.removeHologram(location.getHologram());
      }
    }

    this.locationsData.locations().clear();
    this.locationsData = null;

    this.generatorsData.generators().clear();
    this.generatorsData = null;

    this.playerData.data().clear();
    this.playerData = null;

    this.wandData.wands().clear();
    this.wandData = null;

    this.events.clear();
    this.events = null;

    this.hologramPool = null;
    this.econ = null;
    this.papiHandler = null;
    this.dataSaveTask = null;

    this.metrics.shutdown();

    instance = null;

    getLogger().info("GensPlus has been disabled.");
  }

  public void reloadPlugin() {
    onDisable();
    onEnable();
  }

  /**
   * Registers the plugin commands.
   */
  private void registerCommands() {
    getCommand("gensplus").setExecutor(
        new Commands(generatorsData, playerData, events));
    getCommand("generators").setExecutor(
        new Commands(generatorsData, playerData, events));
    getCommand("selldrops").setExecutor(
        new Commands(generatorsData, playerData, events));
  }

  /**
   * Registers the plugin tab completion.
   */
  private void registerTabCompletion() {
    getCommand("gensplus").setTabCompleter(new CommandsTabCompletion(generatorsData));
    getCommand("selldrops").setTabCompleter(new CommandsTabCompletion(generatorsData));
  }

  /**
   * Loads the bukkit events.
   */
  private void loadBukkitEvents() {
    final HashSet<Listener> events = new HashSet<>();

    events.add(new BlockPlace(locationsData, playerData, getConfig()));
    events.add(new BlockBreak(locationsData, generatorsData));
    events.add(new BlockInteraction(locationsData, getConfig()));
    events.add(new InstantBreak(locationsData, generatorsData));
    events.add(new OnJoin(generatorsData, playerData, getConfig()));
    events.add(new EntityExplode(locationsData, generatorsData));
    events.add(new OnWandUse(wandData, getConfig()));
    events.add(new OnInventoryOpen());
    events.add(new OnInventoryClose());
    events.add(new CraftItem());
    events.add(new SmeltItem());
    events.add(new EnchantItem());
    events.add(new SellCommandListener());
    events.add(new PistonEvent(locationsData));

    if (Bukkit.getPluginManager().getPlugin("BentoBox") != null) {
      events.add(new Bentobox(locationsData));
    }

    if (Bukkit.getPluginManager().getPlugin("IridiumSkyblock") != null) {
      events.add(new IridiumSkyblock(locationsData));
    }

    events.forEach(event -> Bukkit.getPluginManager().registerEvents(event, this));
  }

  /**
   * Registers the plugin tasks.
   */
  private void registerTasks() {
    // Run block data save task every 5 minutes
    dataSaveTask = new DataSaveTask(this);

    dataSaveTask.runTaskTimerAsynchronously(this, 0, 20);

    // Run spawner task every second
    new SpawnerTask(locationsData.locations(), generatorsData)
        .runTaskTimerAsynchronously(this, 0, 20);

    EventLoop eventLoop = new EventLoop(events);

    // Start event loop only if there is at least one event enabled
    if (!events.isEmpty()) {
      eventLoop.runTaskTimerAsynchronously(this, 0, 20);
    }

    CleanupTask cleanupTask = new CleanupTask(locationsData);
    cleanupTask.runTaskTimerAsynchronously(this, 0, 20);
  }

  /**
   * Sets up the economy plugin for handling currency.
   *
   * @throws RuntimeException if Vault or an economy plugin is not found.
   */
  private void setupEconomy() {
    if (getServer().getPluginManager().getPlugin("Vault") == null) {
      throw new RuntimeException("Vault not found");
    }

    RegisteredServiceProvider<Economy> rsp = getServer().getServicesManager()
        .getRegistration(Economy.class);

    if (rsp == null) {
      throw new RuntimeException(
          "No economy plugin found. Please install one, for example EssentialsX.");
    }

    econ = rsp.getProvider();
  }

  /**
   * Loads the list of events based on the plugin configuration.
   *
   * @return The list of events.
   */
  private ArrayList<Event> loadGensPlusEvents() {
    ArrayList<Event> events = new ArrayList<>();
    if (getConfig().getBoolean(Config.EVENTS_DROP_EVENT_ENABLED.getPath())) {
      events.add(
          new DropEvent(getConfig().getLong(Config.EVENTS_DROP_EVENT_MULTIPLIER.getPath()),
              getConfig().getString(Config.EVENTS_DROP_EVENT_NAME.getPath())));
    }

    if (getConfig().getBoolean(Config.EVENTS_SPEED_EVENT_ENABLED.getPath())) {
      events.add(
          new SpeedEvent(getConfig().getLong(Config.EVENTS_SPEED_EVENT_MULTIPLIER.getPath()),
              getConfig().getString(Config.EVENTS_SPEED_EVENT_NAME.getPath())));
    }

    if (getConfig().getBoolean(Config.EVENTS_SELL_EVENT_ENABLED.getPath())) {
      events.add(
          new SellEvent(getConfig().getLong(Config.EVENTS_SELL_EVENT_MULTIPLIER.getPath()),
              getConfig().getString(Config.EVENTS_SELL_EVENT_NAME.getPath())));
    }

    return events;
  }

  /**
   * Loads the generators data from the plugin configuration.
   *
   * @return The generators data.
   * @throws RuntimeException if duplicate tier is found or an invalid item name or item meta is
   *                          encountered.
   */
  @SuppressWarnings("unchecked")
  private GeneratorsData loadGeneratorsData() {
    List<GeneratorsData.Generator> generators = new ArrayList<>();
    List<Map<?, ?>> generatorsConfig = getConfig().getMapList(Config.GENERATORS.getPath());

    for (Map<?, ?> generator : generatorsConfig) {
      final String name = (String) generator.get("name");
      final String dropDisplayName = (String) generator.get("dropDisplayName");
      final boolean instantBreak = (boolean) generator.get("instantBreak");
      int tier = (int) generator.get("tier");
      int speed = (int) generator.get("speed");
      double price = (double) generator.get("price");
      double sellPrice = (double) generator.get("sellPrice");
      String spawnItem = (String) generator.get("spawnItem");
      String blockType = (String) generator.get("blockType");
      List<String> lore =
          ((List<String>) generator.get("lore")).isEmpty() ? getConfig().getStringList(
              Config.DEFAULT_LORE.getPath()) : (List<String>) generator.get("lore");

      lore = lore.stream().map(s -> s.replace("%tier%", String.valueOf(tier)))
          .map(s -> s.replace("%speed%", String.valueOf(speed)))
          .map(s -> s.replace("%price%", String.valueOf(price)))
          .map(s -> s.replace("%sellPrice%", String.valueOf(sellPrice)))
          .map(s -> s.replace("%spawnItem%", spawnItem))
          .map(s -> s.replace("%blockType%", blockType))
          .map(ChatUtil::translate).toList();

      if (generators.stream().anyMatch(g -> g.tier() == tier)) {
        throw new RuntimeException("Duplicate tier found: " + tier);
      }

      ItemStack spawnItemStack = ItemUtil.getUniversalItem(spawnItem, true, true);
      ItemStack blockTypeStack = ItemUtil.getUniversalItem(blockType, false, false);

      if (spawnItemStack == null) {
        getLogger().severe("=============================================");
        getLogger().severe("This is not a bug or crash. Please read below");
        getLogger().severe("And fix the invalid item name in the config");
        getLogger().severe("=============================================");
        throw new RuntimeException(String.format(
            "Invalid blockType: %s for generator %s (tier %d). The plugin will now disable.",
            blockType, name, tier
        ));
      }

      if (blockTypeStack == null) {
        getLogger().severe("=============================================");
        getLogger().severe("This is not a bug or crash. Please read below");
        getLogger().severe("And fix the invalid item name in the config");
        getLogger().severe("=============================================");
        throw new RuntimeException(String.format(
            "Invalid blockType: %s for generator %s (tier %d). The plugin will now disable.",
            blockType, name, tier
        ));
      }

      ItemMeta blockTypeMeta = blockTypeStack.getItemMeta();
      ItemMeta spawnItemMeta = spawnItemStack.getItemMeta();

      if (blockTypeMeta == null || spawnItemMeta == null) {
        throw new RuntimeException("Invalid item meta");
      }

      blockTypeMeta.setDisplayName(ChatUtil.translate(name));
      blockTypeMeta.setLore(lore);

      blockTypeStack.setItemMeta(blockTypeMeta);

      List<String> itemSpawnLore = ((List<String>) generator.get("itemSpawnLore")).isEmpty()
          ? Config.DEFAULT_ITEM_SPAWN_LORE.getStringList()
          : (List<String>) generator.get("itemSpawnLore");

      String formattedSellPrice = econ.format(sellPrice);

      itemSpawnLore = itemSpawnLore.stream().map(s -> s.replace("%tier%", String.valueOf(tier)))
          .map(s -> s.replace("%sellPrice%", formattedSellPrice))
          .map(ChatUtil::translate)
          .toList();

      spawnItemMeta.setDisplayName(ChatUtil.translate(dropDisplayName));
      spawnItemMeta.setLore(itemSpawnLore);

      spawnItemStack.setItemMeta(spawnItemMeta);

      // Store tier as NBT data using the correct format
      spawnItemStack = NBTEditor.set(spawnItemStack, tier, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier");
      blockTypeStack = NBTEditor.set(blockTypeStack, tier, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier");

      if (Config.DEVELOPER_OPTIONS.getBoolean()) {
        getLogger().info("[DEBUG] Created generator item with tier " + tier);
        getLogger().info("[DEBUG] SpawnItem NBT: " + NBTEditor.getInt(spawnItemStack, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier"));
        getLogger().info("[DEBUG] BlockType NBT: " + NBTEditor.getInt(blockTypeStack, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier"));
      }

      generators.add(new GeneratorsData.Generator(
          name,
          tier,
          price,
          sellPrice,
          speed,
          spawnItemStack,
          blockTypeStack,
          lore,
          instantBreak
      ));
    }

    return new GeneratorsData(generators);
  }

  @SuppressWarnings("unchecked")
  private void loadHolograms() {
    if (getServer().getPluginManager().getPlugin("HoloEasy") == null
        && Config.HOLOGRAMS_ENABLED.getBoolean()) {
      getLogger().warning("HoloEasy not found. Disabling plugin.");
      Bukkit.getPluginManager().disablePlugin(this);
      return;
    }

    if (!Config.HOLOGRAMS_ENABLED.getBoolean()) {
      return;
    }

    hologramPool = HoloEasy.startInteractivePool(
        this,
        Config.HOLOGRAMS_VIEW_DISTANCE.getInt(),
        0.5f,
        5f
    );

    if (!GensPlus.getInstance().getConfig().getBoolean(Config.HOLOGRAMS_ENABLED.getPath())) {
      return;
    }

    List<Map<?, ?>> generatorsConfig = instance.getConfig().getMapList("generators");

    for (LocationsData.GeneratorLocation location : getLocationsData().locations()) {
      GeneratorsData.Generator generator = generatorsData.getGenerator(location.getGenerator());

      Material material = XMaterial.matchXMaterial(generator.blockType().getType().toString())
          .orElseThrow(() -> new RuntimeException("Invalid item stack"))
          .parseItem()
          .getType();

      Map<?, ?> matchingGeneratorConfig = generatorsConfig.stream()
          .filter(generatorConfig -> generatorConfig.get("name").equals(generator.name()))
          .findFirst()
          .orElse(null);

      if (matchingGeneratorConfig == null) {
        continue;
      }

      List<String> lines = ((List<String>) matchingGeneratorConfig.get("hologramLines")).isEmpty()
          ? GensPlus.getInstance().getConfig()
          .getStringList(Config.DEFAULT_HOLOGRAM_LINES.getPath())
          : (List<String>) matchingGeneratorConfig.get("hologramLines");

      lines = lines
          .stream()
          .map(line -> line.replace("%name%", generator.name()))
          .map(line -> line.replace("%tier%", String.valueOf(generator.tier())))
          .map(line -> line.replace("%speed%", String.valueOf(generator.speed())))
          .map(line -> line.replace("%spawnItem%", generator.spawnItem().getType().toString()))
          .map(line -> line.replace("%sellPrice%", String.valueOf(generator.sellPrice())))
          .map(ChatUtil::translate)
          .toList();

      Location center = location.getCenter();
      Hologram hologram = HologramsUtil.createHologram(center, lines, material);
      location.setHologram(hologram);
    }
  }

  /**
   * Load player data in case the plugin gets enabled manually after server start.
   */
  private void loadPlayers() {
    for (Player player : Bukkit.getOnlinePlayers()) {
      if (playerData.getData(player.getUniqueId()) == null) {
        playerData.create(player.getUniqueId(), Config.LIMIT_PER_PLAYER_DEFAULT_LIMIT.getInt());
      }
    }
  }

  private CopyOnWriteArrayList<LocationsData.GeneratorLocation> loadBlockDataFromJson() {
    try (FileReader reader = new FileReader(getDataFolder() + "/data/block_data.json")) {
      return gson.fromJson(reader,
          new TypeToken<CopyOnWriteArrayList<LocationsData.GeneratorLocation>>() {
          }.getType());
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private List<WandData.Wand> loadWandsDataFromJson() {
    try (FileReader reader = new FileReader(getDataFolder() + "/data/wands_data.json")) {
      return gson.fromJson(reader,
          new TypeToken<List<WandData.Wand>>() {
          }.getType());
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private List<PlayerData.Data> loadPlayerDataFromJson() {
    try (FileReader reader = new FileReader(getDataFolder() + "/data/player_data.json")) {
      return gson.fromJson(reader,
          new TypeToken<List<PlayerData.Data>>() {
          }.getType());
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * Moves the "block_data.json" file to the "/data/" directory if it exists in the plugin's data
   */
  public void moveBlockData() {
    // Check if "block_data.json" exists in the plugin's data folder
    File blockDataFile = new File(getDataFolder(), "/block_data.json");
    if (blockDataFile.exists()) {
      // Create the "/data/" directory if it doesn't exist
      File targetDirectory = new File(getDataFolder(), "data");
      if (!targetDirectory.exists()) {
        //noinspection ResultOfMethodCallIgnored
        targetDirectory.mkdirs();
      }

      try {
        // Move the file to the "/data/" directory
        Path sourcePath = Paths.get(blockDataFile.toURI());
        Path targetPath = Paths.get(getDataFolder().getPath(), "/data/block_data.json");
        Files.move(sourcePath, targetPath);
        getLogger().info("block_data.json moved to /data/ directory successfully.");
      } catch (Exception e) {
        getLogger().warning(
            "Failed to move block_data.json to /data/ directory: " + e.getMessage());
      }
    }
  }

  private void saveResourceIfNotExists(String resourcePath, boolean replace) {
    File file = new File(getDataFolder(), resourcePath);
    if (!file.exists()) {
      saveResource(resourcePath, replace);
    }
  }

}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\commands\Commands.java
================================================================================

package xyz.arcadiadevs.gensplus.commands;

import com.awaitquality.api.spigot.chat.ChatUtil;
import org.bukkit.Bukkit;
import org.bukkit.OfflinePlayer;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.guis.GeneratorsGui;
import xyz.arcadiadevs.gensplus.guis.ListGui;
import xyz.arcadiadevs.gensplus.guis.SellGui;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.models.events.Event;
import xyz.arcadiadevs.gensplus.tasks.EventLoop;
import xyz.arcadiadevs.gensplus.utils.ItemUtil;
import xyz.arcadiadevs.gensplus.utils.SellUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.List;

/**
 * The Commands class implements the CommandExecutor interface to handle custom commands in
 * GensPlus. It provides functionality for various commands related to generators and the
 * plugin itself.
 */
public class Commands implements CommandExecutor {

  private final GeneratorsData generatorsData;
  private final PlayerData playerData;
  private final List<Event> events;

  private long lastReload = 0;

  /**
   * Constructor for initializing the Commands object.
   *
   * @param generatorsData Data related to generators
   * @param playerData Player-related data
   * @param events List of events
   */
  public Commands(GeneratorsData generatorsData, PlayerData playerData, List<Event> events) {
    this.generatorsData = generatorsData;
    this.playerData = playerData;
    this.events = events;
  }

  /**
   * Executes a command issued by a CommandSender.
   *
   * @param commandSender The CommandSender who issued the command.
   * @param command       The Command object representing the executed command.
   * @param s             The label of the command.
   * @param strings       The arguments provided with the command.
   * @return true if the command was handled successfully, false otherwise.
   */
  @Override
  public boolean onCommand(@NotNull CommandSender commandSender, @NotNull Command command,
                           @NotNull String s, @NotNull String[] strings) {
    final boolean adminPermission = commandSender.hasPermission(Permissions.ADMIN.getPermission());

    if (command.getName().equalsIgnoreCase("gensplus")) {
      if (strings.length == 0) {
        Messages.DEFAULT_MESSAGE.format("version",
            GensPlus.getInstance().getDescription().getVersion()).send(commandSender);
        return true;
      }

      if (strings[0].equalsIgnoreCase("help")) {
        ChatUtil.sendMessage(commandSender,
            "&9GensPlus Commands:");
        ChatUtil.sendMessage(commandSender,
            "&7- /gensplus: Display plugin version");
        ChatUtil.sendMessage(commandSender,
            "&7- /gensplus give <player> <tier> [amount]: Give a generator to a player");
        ChatUtil.sendMessage(commandSender,
            "&7- /gensplus giveall <tier> [amount]: Give a generator to all players");
        ChatUtil.sendMessage(commandSender,
            "&7- /gensplus wand sell <player> <uses> <multiplier>: Give a sell wand to a player");
        ChatUtil.sendMessage(commandSender,
            "&7- /gensplus setlimit <player> <limit>: Set a player's generator limit");
        ChatUtil.sendMessage(commandSender,
            "&7- /selldrops hand/all: Sell all drops in your hand or inventory");
        ChatUtil.sendMessage(commandSender,
            "&7- /generators: view all generators");
        return true;
      }

      // generators list of all players that have generators
      if (strings[0].equalsIgnoreCase("list")) {
        if (!adminPermission) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        OfflinePlayer player = (Player) commandSender;

        ListGui.open(player.getPlayer());
        return true;
      }

      if (strings[0].equalsIgnoreCase("setlimit")) {
        if (!adminPermission) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        if (strings.length < 3) {
          Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
          return true;
        }

        if (!strings[2].matches("\\d+")) {
          Messages.INVALID_FORMAT.format().send(commandSender);
          return true;
        }

        final Player targetPlayer = Bukkit.getPlayer(strings[1]);

        if (targetPlayer == null) {
          Messages.PLAYER_NOT_FOUND.format().send(commandSender);
          return true;
        }

        PlayerData.Data data = playerData.getData(targetPlayer.getUniqueId());
        data.setLimit(Integer.parseInt(strings[2]));
        Messages.LIMIT_UPDATED.format(
                "limit", strings[2],
                "player", targetPlayer.getName())
            .send(commandSender);

        return true;
      }

      if (strings[0].equalsIgnoreCase("addlimit")) {
        if (!adminPermission) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        if (strings.length < 3) {
          Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
          return true;
        }

        if (!strings[2].matches("\\d+")) {
          Messages.INVALID_FORMAT.format().send(commandSender);
          return true;
        }

        final Player targetPlayer = Bukkit.getPlayer(strings[1]);

        if (targetPlayer == null) {
          Messages.PLAYER_NOT_FOUND.format().send(commandSender);
          return true;
        }

        PlayerData.Data data = playerData.getData(targetPlayer.getUniqueId());
        PlayerData.Data.addToLimit(data, Integer.parseInt(strings[2]));
        Messages.LIMIT_UPDATED.format(
                "limit", data.getLimit(),
                "player", targetPlayer.getName())
            .send(commandSender);

      }

      if (strings[0].equalsIgnoreCase("wand")) {
        if (strings.length < 2) {
          Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
          return true;
        }

        if (strings[1].equalsIgnoreCase("sell")) {
          if (!commandSender.hasPermission(Permissions.GIVE_WAND.getPermission())) {
            Messages.NO_PERMISSION.format().send(commandSender);
            return true;
          }

          if (strings.length < 5) {
            Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
            return true;
          }

          if (!strings[3].matches("-?\\d+") || !strings[4].matches("\\d+\\.?\\d*")) {
            Messages.INVALID_FORMAT.format().send(commandSender);
            return true;
          }

          final Player targetPlayer = Bukkit.getPlayer(strings[2]);

          targetPlayer.getInventory().addItem(ItemUtil.getSellWand(Integer.parseInt(strings[3]),
              Double.parseDouble(strings[4])));
          Messages.SELL_WAND_GIVEN.format().send(commandSender);
          Messages.SELL_WAND_RECEIVED.format().send(targetPlayer);
          return true;
        }

        return true;
      }

      if (strings[0].equalsIgnoreCase("startevent")) {
        if (strings.length < 2) {
          Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
          return true;
        }

        if (EventLoop.getActiveEvent().event() != null) {
          Messages.EVENT_ALREADY_RUNNING.format().send(commandSender);
          return true;
        }

        // event name can be multiple words
        String event = String.join(" ", strings).substring(11);

        Event eventObj = events.stream()
            .filter(e -> e.getName().equalsIgnoreCase(event))
            .findFirst()
            .orElse(null);

        if (eventObj == null) {
          Messages.EVENT_NOT_FOUND.format().send(commandSender);
          return true;
        }

        EventLoop.setNextEvent(eventObj);

      }

      if (strings[0].equalsIgnoreCase("stopevent")) {
        EventLoop.stopEvent();
      }

      if (strings[0].equalsIgnoreCase("reload")) {
        if (!(adminPermission || commandSender.hasPermission(Permissions.GENERATOR_RELOAD.getPermission()))) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        long currentTime = System.currentTimeMillis();
        long reloadCooldown = 5000;
        if (currentTime - lastReload < reloadCooldown) {
          Messages.TOO_FAST.format().send(commandSender);
          return true;
        }

        GensPlus.getInstance().reloadPlugin();
        Messages.PLUGIN_RELOADED.format().send(commandSender);

        // Update lastReload after successful command execution
        lastReload = currentTime;
        return true;
      }

      if (strings[0].equalsIgnoreCase("give")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.GENERATOR_GIVE.getPermission()))) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        if (strings.length < 3) {
          Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
          return true;
        }

        Player targetPlayer = Bukkit.getPlayer(strings[1]);
        if (targetPlayer == null) {
          Messages.PLAYER_NOT_FOUND.format().send(commandSender);
          return true;
        }

        int tier;
        try {
          tier = Integer.parseInt(strings[2]);
        } catch (NumberFormatException e) {
          Messages.INVALID_GENERATOR_TIER.format().send(commandSender);
          return true;
        }

        int amount = 1;
        if (strings.length >= 4) {
          try {
            amount = Integer.parseInt(strings[3]);
          } catch (NumberFormatException e) {
            Messages.INVALID_AMOUNT.format().send(commandSender);
            return true;
          }
        }

        GeneratorsData.Generator generator = generatorsData.getGenerator(tier);
        if (generator == null) {
          Messages.INVALID_GENERATOR_TIER.format().send(commandSender);
          return true;
        }

        for (int i = 0; i < amount; i++) {
          generator.giveItem(targetPlayer);
        }

        Messages.GENERATOR_GIVEN.format(
                "targetPlayer", targetPlayer.getName(),
                "tier", String.valueOf(tier),
                "amount", String.valueOf(amount))
            .send(commandSender);

        Messages.GENERATOR_RECEIVED.format(
                "tier", String.valueOf(tier),
                "amount", String.valueOf(amount))
            .send(targetPlayer);

        return true;
      }

      if (strings[0].equalsIgnoreCase("giveall")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.GENERATOR_GIVE_ALL.getPermission()))) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        if (strings.length < 2) {
          Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
          return true;
        }

        int tier;
        try {
          tier = Integer.parseInt(strings[1]);
        } catch (NumberFormatException e) {
          Messages.INVALID_GENERATOR_TIER.format().send(commandSender);
          return true;
        }

        int amount = 1;
        if (strings.length >= 3) {
          try {
            amount = Integer.parseInt(strings[2]);
          } catch (NumberFormatException e) {
            Messages.INVALID_AMOUNT.format().send(commandSender);
            return true;
          }
        }

        GeneratorsData.Generator generator = generatorsData.getGenerator(tier);
        if (generator == null) {
          Messages.INVALID_GENERATOR_TIER.format().send(commandSender);
          return true;
        }

        int givenCount = 0;
        for (Player targetPlayer : Bukkit.getOnlinePlayers()) {
          for (int i = 0; i < amount; i++) {
            generator.giveItem(targetPlayer);
          }

          givenCount++;
        }

        Messages.GENERATOR_GIVEN_ALL.format(
                "tier", String.valueOf(tier),
                "amount", String.valueOf(amount),
                "count", String.valueOf(givenCount))
            .send(commandSender);

        return true;
      }
    }

    if (command.getName().equalsIgnoreCase("generators")) {
      if (!(commandSender instanceof Player player)) {
        Messages.ONLY_PLAYER_CAN_EXECUTE_COMMAND.format().send(commandSender);
        return true;
      }

      if (!(adminPermission || commandSender.hasPermission(Permissions.GENERATORS_GUI.getPermission()))) {
        Messages.NO_PERMISSION.format().send(commandSender);
        return true;
      }

      GeneratorsGui.open(player);
      return true;
    }

    if (command.getName().equalsIgnoreCase("selldrops")) {
      if (!(commandSender instanceof Player player)) {
        Messages.ONLY_PLAYER_CAN_EXECUTE_COMMAND.format().send(commandSender);
        return true;
      }

      if (!GensPlus.getInstance().getConfig()
          .getBoolean(Config.SELL_COMMAND_ENABLED.getPath())) {
        return true;
      }

      if (strings.length == 0) {
        Messages.NOT_ENOUGH_ARGUMENTS.format().send(commandSender);
        return true;
      }

      if (strings[0].equalsIgnoreCase("all")) {
        if (!commandSender.hasPermission(Permissions.GENERATOR_DROPS_SELL_ALL.getPermission())) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        SellUtil.sellAll(player, player.getInventory());
        return true;
      }

      if (strings[0].equalsIgnoreCase("hand")) {
        if (!commandSender.hasPermission(Permissions.GENERATOR_DROPS_SELL_HAND.getPermission())) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        SellUtil.sellHand(player);
        return true;
      }

      if (strings[0].equalsIgnoreCase("gui")) {
        if (!commandSender.hasPermission(Permissions.GENERATOR_DROPS_SELL_GUI.getPermission())) {
          Messages.NO_PERMISSION.format().send(commandSender);
          return true;
        }

        SellGui.open(player);
        return true;
      }
    }

    return true;
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\commands\CommandsTabCompletion.java
================================================================================

package xyz.arcadiadevs.gensplus.commands;

import lombok.AllArgsConstructor;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.TabCompleter;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * The CommandsTabCompletion class implements the TabCompleter interface to provide tab completion
 * for custom commands in GensPlus.
 */

@AllArgsConstructor
public class CommandsTabCompletion implements TabCompleter {

  private final GeneratorsData generatorsData;

  @Nullable
  @Override
  public List<String> onTabComplete(@NotNull CommandSender commandSender,
                                    @NotNull Command command,
                                    @NotNull String s,
                                    @NotNull String[] strings) {

    final boolean adminPermission = commandSender.hasPermission(Permissions.ADMIN.getPermission());

    if (command.getName().equalsIgnoreCase("gensplus")
        || command.getName().equalsIgnoreCase("gens")
        || command.getName().equalsIgnoreCase("gp")) {

      if (strings.length == 1) {
        if (!(adminPermission || commandSender.hasPermission(Permissions.ADMIN.getPermission()))) {
          return null;
        }

        return List.of("help", "list", "give", "giveall", "wand", "setlimit",
            "addlimit", "startevent", "stopevent", "reload");
      }

      if (strings[0].equalsIgnoreCase("reload")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.GENERATOR_RELOAD.getPermission()))) {
          return null;
        }
      }

      if (strings[0].equalsIgnoreCase("setlimit")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.SET_LIMIT.getPermission()))) {
          return null;
        }

        if (strings.length == 2) {
          List<String> playerNames = new ArrayList<>();
          for (Player player : commandSender.getServer().getOnlinePlayers()) {
            playerNames.add(player.getName());
          }

          return playerNames;
        }

        if (strings.length == 3) {
          return List.of("<limit>");
        }

      }

      if (strings[0].equalsIgnoreCase("addlimit")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.ADD_LIMIT.getPermission()))) {
          return null;
        }

        if (strings.length == 2) {
          List<String> playerNames = new ArrayList<>();
          for (Player player : commandSender.getServer().getOnlinePlayers()) {
            playerNames.add(player.getName());
          }

          return playerNames;
        }

        if (strings.length == 3) {
          return List.of("<limit>");
        }

      }

      if (strings[0].equalsIgnoreCase("startevent")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.START_EVENT.getPermission()))) {
          return null;
        }

        if (strings.length == 2) {
          List<String> listEvents = new ArrayList<>();

          if (Config.EVENTS_SPEED_EVENT_ENABLED.getBoolean()) {
            listEvents.add(Config.EVENTS_SPEED_EVENT_NAME.getString());
          }
          if (Config.EVENTS_SELL_EVENT_ENABLED.getBoolean()) {
            listEvents.add(Config.EVENTS_SELL_EVENT_NAME.getString());
          }
          if (Config.EVENTS_DROP_EVENT_ENABLED.getBoolean()) {
            listEvents.add(Config.EVENTS_DROP_EVENT_NAME.getString());
          }

          return listEvents;
        }
      }

      if (strings[0].equalsIgnoreCase("stopevent")) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.STOP_EVENT.getPermission()))) {
          return null;
        }
      }

      if (Arrays.stream(strings).anyMatch(string -> string.equalsIgnoreCase("give"))) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.GENERATOR_GIVE.getPermission()))) {
          return null;
        }

        if (strings.length == 2) {
          List<String> playerNames = new ArrayList<>();
          for (Player player : commandSender.getServer().getOnlinePlayers()) {
            playerNames.add(player.getName());
          }

          return playerNames;
        }

        if (strings.length == 3) {
          List<Integer> generatorTiers = generatorsData.getGenerators()
              .stream()
              .map(GeneratorsData.Generator::tier)
              .toList();

          return generatorTiers.stream().map(String::valueOf).toList();
        }

        if (strings.length == 4) {
          return List.of("[amount]");
        }
      }

      if (Arrays.stream(strings).anyMatch(string -> string.equalsIgnoreCase("giveall"))) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.GENERATOR_GIVE_ALL.getPermission()))) {
          return null;
        }

        if (strings.length == 2) {
          List<Integer> generatorTiers = generatorsData.getGenerators()
              .stream()
              .map(GeneratorsData.Generator::tier)
              .toList();

          return generatorTiers.stream().map(String::valueOf).toList();
        }

        if (strings.length == 3) {
          return List.of("[amount]");
        }
      }

      if (Arrays.stream(strings).anyMatch(string -> string.equalsIgnoreCase("wand"))) {
        if (!(adminPermission
            || commandSender.hasPermission(Permissions.GIVE_WAND.getPermission()))) {
          return null;
        }

        if (strings.length == 2) {
          return List.of("sell");
        }

        if (strings.length == 3) {
          List<String> playerNames = new ArrayList<>();
          for (Player player : commandSender.getServer().getOnlinePlayers()) {
            playerNames.add(player.getName());
          }

          return playerNames;
        }

        if (strings.length == 4) {
          return List.of("<uses>", "-1");
        }

        if (strings.length == 5) {
          return List.of("<multiplier>");
        }
      }

      return null;
    }

    if (command.getName().equalsIgnoreCase("selldrops")) {
      if (!(Config.SELL_COMMAND_ENABLED.getBoolean())) {
        return null;
      }

      if (!commandSender.hasPermission(Permissions.GENERATOR_DROPS_SELL_ALL.getPermission())
          || !commandSender.hasPermission(Permissions.GENERATOR_DROPS_SELL_HAND.getPermission())
          || !commandSender.hasPermission(Permissions.GENERATOR_DROPS_SELL_GUI.getPermission())) {
        return null;
      }

      if (strings.length == 1) {
        return List.of("hand", "all", "gui");
      }

      return null;
    }

    return null;
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\commands\SellCommandListener.java
================================================================================

package xyz.arcadiadevs.gensplus.commands;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import xyz.arcadiadevs.gensplus.guis.SellGui;
import xyz.arcadiadevs.gensplus.utils.SellUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.List;

public class SellCommandListener implements Listener {
  @EventHandler(priority = EventPriority.HIGHEST)
  public void onPlayerCommandPreprocess(PlayerCommandPreprocessEvent event) {
    Player player = event.getPlayer();
    String[] args = event.getMessage().split(" ");
    args[0] = args[0].toLowerCase();


    if (!Config.SELL_COMMAND_ENABLED.getBoolean()) {
      return;
    }

    List<String> commands = Config.SELL_COMMAND_ALLIASES.getStringList();
    String sentCommand = args[0].replace("/", "");

    if (!commands.contains(sentCommand)) {
      return;
    }

    if (args.length < 2) {
      Messages.NOT_ENOUGH_ARGUMENTS.format().send(player);
      event.setCancelled(true);
      return;
    }

    if (args[1].equalsIgnoreCase("all")) {
      if (!player.hasPermission(Permissions.GENERATOR_DROPS_SELL_ALL.getPermission())) {
        Messages.NO_PERMISSION.format().send(player);
        return;
      }

      SellUtil.sellAll(player, player.getInventory());
      event.setCancelled(true);
      return;
    }

    if (args[1].equalsIgnoreCase("hand")) {
      if (!player.hasPermission(Permissions.GENERATOR_DROPS_SELL_HAND.getPermission())) {
        Messages.NO_PERMISSION.format().send(player);
        return;
      }

      SellUtil.sellHand(player);
      event.setCancelled(true);
      return;
    }

    if (args[1].equalsIgnoreCase("gui")) {
      if (!player.hasPermission(Permissions.GENERATOR_DROPS_SELL_GUI.getPermission())) {
        Messages.NO_PERMISSION.format().send(player);
        return;
      }

      SellGui.open(player);
      event.setCancelled(true);
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\BlockBreak.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import com.cryptomorin.xseries.XMaterial;
import lombok.AllArgsConstructor;
import org.bukkit.OfflinePlayer;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.ArrayList;

/**
 * Handles the BlockBreakEvent triggered when a player breaks a block.
 */
@AllArgsConstructor
public class BlockBreak implements Listener {

  private LocationsData locationsData;
  private GeneratorsData generatorsData;

  /**
   * Handles the BlockBreakEvent triggered when a player breaks a block.
   *
   * @param event The BlockBreakEvent object representing the block break event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onBlockBreak(BlockBreakEvent event) {
    final Block eventBlock = event.getBlock();
    final LocationsData.GeneratorLocation generatorLocation =
        locationsData.getGeneratorLocation(eventBlock);

    if (generatorLocation == null) {
      return;
    }

    if (generatorLocation.getPlacedBy() != event.getPlayer()
        && !event.getPlayer().isOp()
        && !event.getPlayer().hasPermission(Permissions.ADMIN.getPermission())) {
      Messages.NOT_YOUR_GENERATOR_UPGRADE.format().send(event.getPlayer());
      event.setCancelled(true);
      return;
    }

    GeneratorsData.Generator generator =
        generatorsData.getGenerator(generatorLocation.getGenerator());

    final OfflinePlayer player = generatorLocation.getPlacedBy();
    final int tier = generatorLocation.getGenerator();
    ArrayList<Block> blocks = generatorLocation.getBlockLocations();

    // Generate and drop the generator item for the player
    if (GensPlus.getInstance().getConfig().getBoolean(Config.INSTANT_PICKUP.getPath())) {
      generator.giveItem((Player) player);
    } else {
      generator.dropItem(event.getPlayer(), eventBlock.getLocation());
    }

    blocks.remove(eventBlock);

    locationsData.removeLocation(generatorLocation);

    if (Config.DEVELOPER_OPTIONS.getBoolean()) {
      GensPlus.getInstance().getLogger().info("[BLOCKBREAK] 3. Removing location: " + generatorLocation);
    }

    blocks.forEach(block -> {
      LocationsData.GeneratorLocation loc = locationsData.getGeneratorLocation(block);

      if (loc != null) {
        return;
      }

      locationsData.createLocation(player, tier, block);
    });

    if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_12)) {
      event.setDropItems(false);
    } else {
      event.setCancelled(true);
      event.getBlock().setType(XMaterial.AIR.parseMaterial());
    }

    // Send a notification to the player
    Messages.SUCCESSFULLY_DESTROYED.format().send(event.getPlayer());
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\BlockInteraction.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import com.cryptomorin.xseries.XMaterial;
import lombok.AllArgsConstructor;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.block.BlockFadeEvent;
import org.bukkit.event.block.BlockFormEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.EquipmentSlot;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.guis.UpgradeGui;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.Arrays;

@AllArgsConstructor
public class BlockInteraction implements Listener {

  private final LocationsData locationsData;
  private final FileConfiguration config;

  /**
   * Handles the PlayerInteractEvent triggered when a player interacts with a block. If the block is
   * a generator block and the player is sneaking and right-clicks the block, it opens the upgrade
   * GUI.
   *
   * @param event The PlayerInteractEvent object representing the player's interaction event.
   */
  @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
  public void onBlockClick(PlayerInteractEvent event) {
    if (ServerVersion.isServerVersionAbove(ServerVersion.V1_8)
        && event.getHand() != EquipmentSlot.HAND) {
      return;
    }

    Block block = event.getClickedBlock();
    Player player = event.getPlayer();

    if (block == null) {
      return;
    }

    LocationsData.GeneratorLocation generatorLocation = locationsData.getGeneratorLocation(block);

    if (generatorLocation == null) {
      return;
    }

    final boolean needsSneak = Config.GENERATOR_UPGRADE_SNEAK.getBoolean();
    final String actionValue = Config.GENERATOR_UPGRADE_ACTION.getString();

    if ((needsSneak && !player.isSneaking())
        || event.getAction() != Action.valueOf(actionValue)) {
      return;
    }

    GeneratorsData.Generator generator = generatorLocation.getGeneratorObject();

    if (generator == null) {
      return;
    }

    event.setCancelled(true);

    if (Config.GUIS_UPGRADE_GUI_ENABLED.getBoolean()) {
      UpgradeGui.open(player, generatorLocation, block);
    } else {
      if (generatorLocation.getPlacedBy() != player
          && !player.hasPermission(Permissions.ADMIN.getPermission())
          && !player.isOp()) {
        Messages.NOT_YOUR_GENERATOR_UPGRADE.format().send(player);
        return;
      }
      UpgradeGui.upgradeGenerator(player, generatorLocation, block);
    }
  }

  /**
   * Handles the PlayerInteractEvent with a beacon block.
   *
   * @param event The PlayerInteractEvent object representing the player interact event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void beaconInteract(PlayerInteractEvent event) {
    final LocationsData.GeneratorLocation location =
        locationsData.getGeneratorLocation(event.getClickedBlock());

    if (location == null) {
      return;
    }

    if (event.getClickedBlock() != null
        && event.getClickedBlock().getType() == Material.BEACON
        && location.getGeneratorObject().blockType().getType() == Material.BEACON
        && event.getAction() == Action.RIGHT_CLICK_BLOCK) {
      event.setCancelled(true);
    }
  }

  /**
   * Handles the PlayerInteractEvent triggered when a player interacts with a dragon egg.
   *
   * @param event The PlayerInteractEvent object representing the player interact event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void eggInteract(PlayerInteractEvent event) {
    final LocationsData.GeneratorLocation location =
        locationsData.getGeneratorLocation(event.getClickedBlock());

    if (location == null) {
      return;
    }

    if (event.getClickedBlock() != null
        && event.getClickedBlock().getType() == XMaterial.DRAGON_EGG.parseMaterial()
        && location.getGeneratorObject().blockType().getType()
        == XMaterial.DRAGON_EGG.parseMaterial()) {
      event.setCancelled(true);
    }
  }

  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onItemUse(PlayerInteractEvent event) {
    final LocationsData.GeneratorLocation location =
        locationsData.getGeneratorLocation(event.getClickedBlock());

    if (location == null) {
      return;
    }

    if (event.getAction() != Action.RIGHT_CLICK_BLOCK) {
      return;
    }

    ItemStack[] shovels = {
      XMaterial.WOODEN_SHOVEL.parseItem(),
      XMaterial.STONE_SHOVEL.parseItem(),
      XMaterial.IRON_SHOVEL.parseItem(),
      XMaterial.GOLDEN_SHOVEL.parseItem(),
      XMaterial.DIAMOND_SHOVEL.parseItem(),
      XMaterial.NETHERITE_SHOVEL.parseItem()
    };

    ItemStack[] hoes = {
      XMaterial.WOODEN_HOE.parseItem(),
      XMaterial.STONE_HOE.parseItem(),
      XMaterial.IRON_HOE.parseItem(),
      XMaterial.GOLDEN_HOE.parseItem(),
      XMaterial.DIAMOND_HOE.parseItem(),
      XMaterial.NETHERITE_HOE.parseItem()
    };

    if (Arrays.asList(shovels).contains(event.getItem())
        || Arrays.asList(hoes).contains(event.getItem())) {
      event.setCancelled(true);
    }
  }

  /**
   * Handles the BlockFormEvent triggered when a player interacts with a concrete powder block.
   *
   * @param event The PlayerInteractEvent object representing the player interact event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onConcreteForm(BlockFormEvent event) {
    if (event.getNewState().getType().name().contains("CONCRETE")) {
      final LocationsData.GeneratorLocation location =
          locationsData.getGeneratorLocation(event.getBlock());

      if (location == null) {
        return;
      }

      event.setCancelled(true);
    }
  }

  /**
   * Handles the BlockFadeEvent triggered when a player interacts with a coral block.
   *
   * @param event The PlayerInteractEvent object representing the player interact event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onCoralForm(BlockFadeEvent event) {
    if (event.getNewState().getType().name().contains("CORAL")) {
      final LocationsData.GeneratorLocation location =
          locationsData.getGeneratorLocation(event.getBlock());

      if (location == null) {
        return;
      }

      event.setCancelled(true);
    }
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\BlockPlace.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import io.github.bananapuncher714.nbteditor.NBTEditor;
import lombok.AllArgsConstructor;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.utils.LimitUtil;
import xyz.arcadiadevs.gensplus.utils.SkyblockUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.List;

/**
 * The BlockPlace class provides functionality for handling the BlockPlaceEvent in GensPlus.
 * It handles the placement of generator blocks.
 */
@AllArgsConstructor
public class BlockPlace implements Listener {

  private LocationsData locationsData;
  private PlayerData playerData;
  private FileConfiguration config;

  /**
   * Handles the BlockPlaceEvent triggered when a player places a block.
   *
   * @param event The BlockPlaceEvent object representing the block place event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onBlockPlace(BlockPlaceEvent event) {
    final Player player = event.getPlayer();
    final ItemStack item = event.getItemInHand();

    final List<String> disabledWorlds = config.getStringList(Config.DISABLED_WORLDS.getPath());

    if (Config.DEVELOPER_OPTIONS.getBoolean()) {
      player.sendMessage("[DEBUG] Placing item: " + item.getType());
      player.sendMessage("[DEBUG] Has spawn NBT: " + NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier"));
      player.sendMessage("[DEBUG] Has block NBT: " + NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier"));
      if (NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier")) {
        player.sendMessage("[DEBUG] Block tier: " + NBTEditor.getInt(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier"));
      }
    }

    for (String world : disabledWorlds) {
      if (event.getBlockPlaced().getWorld().getName().equals(world)) {
        Messages.CANNOT_PLACE_IN_WORLD.format("world", world).send(event.getPlayer());
        event.setCancelled(true);
        return;
      }
    }

    if (NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")
        && !Config.CAN_DROPS_BE_PLACED.getBoolean()) {
      event.setCancelled(true);
      return;
    }

    if (!NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier")) {
      return;
    }

    final int tier = NBTEditor.getInt(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier");
    final boolean enabled = Config.LIMIT_PER_PLAYER_ENABLED.getBoolean();

    int combinedLimit = LimitUtil.calculateCombinedLimit(player, playerData);

    if (Config.LIMIT_PER_ISLAND_ENABLED.getBoolean()) {
      int limitPerIsland = (int) SkyblockUtil.calculateLimit(player);
      String islandId = SkyblockUtil.getIslandId(event.getBlock().getLocation());

      if (locationsData.getGeneratorsCountByIsland(islandId) >= limitPerIsland) {
        Messages.LIMIT_REACHED.format("limit", limitPerIsland).send(player);
        event.setCancelled(true);
        return;
      }
    }

    if (Config.LIMIT_PER_ISLAND_ENABLED.getBoolean()) {
      combinedLimit = (int) SkyblockUtil.calculateLimit(player);
    }

    if (enabled && locationsData.getGeneratorsCountByPlayer(player) >= combinedLimit) {
      Messages.LIMIT_REACHED.format("limit", combinedLimit).send(player);
      event.setCancelled(true);
      return;
    }

    locationsData.createLocation(player, tier, event.getBlockPlaced());

    // Send a notification to the player
    Messages.SUCCESSFULLY_PLACED.format("tier", tier).send(player);
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\CraftItem.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import io.github.bananapuncher714.nbteditor.NBTEditor;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.CraftItemEvent;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.utils.config.Config;

/**
 * A listener class for handling events related to crafting tables.
 * This class is responsible for checking the items in a crafting matrix
 * and performing certain actions based on their attributes.
 */
public class CraftItem implements Listener {

  /**
   * Called when a crafting event occurs in a crafting table.
   * This method checks the items in the crafting matrix and
   * performs actions based on their attributes.
   *
   * @param event The CraftingInventory event representing the crafting action.
   */

  @EventHandler
  public void onItemCraft(CraftItemEvent event) {
    if (Config.CAN_DROPS_BE_USED_IN_CRAFTING.getBoolean()) {
      return;
    }

    ItemStack[] item = event.getInventory().getMatrix();
    for (ItemStack stack : item) {
      if (stack == null) {
        continue;
      }

      // Check if the item has specific attributes using NBTEditor
      if (NBTEditor.contains(stack, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")
          || NBTEditor.contains(stack, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier")) {
        event.setResult(Event.Result.DENY);
        event.setCancelled(true);
        return;
      }
    }
  }
}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\EnchantItem.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import io.github.bananapuncher714.nbteditor.NBTEditor;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.enchantment.EnchantItemEvent;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.utils.config.Config;

/**
 * A listener class for handling events related to enchanting items.
 * This class is responsible for checking the items in an enchanting table
 * and performing certain actions based on their attributes.
 */
public class EnchantItem implements Listener {

  /**
   * Called when an enchanting event occurs in an enchanting table.
   * This method checks the items in the enchanting table and
   * performs actions based on their attributes.
   *
   * @param event The EnchantItemEvent event representing the enchanting action.
   */
  @EventHandler
  public void onItemEnchant(EnchantItemEvent event) {
    if (Config.CAN_DROPS_BE_USED_IN_ENCHANTING.getBoolean()) {
      return;
    }

    ItemStack item = event.getItem();
    if (NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")
        || NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier")) {
      event.setCancelled(true);
    }

    ItemStack secondItem = event.getView().getItem(1);
    if (secondItem != null && (NBTEditor.contains(secondItem, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")
        || NBTEditor.contains(secondItem, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier"))) {
      event.setCancelled(true);
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\EntityExplode.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import java.util.List;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityExplodeEvent;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;

/**
 * Handles the EntityExplodeEvent triggered when an entity explodes.
 */
public record EntityExplode(LocationsData locationsData, GeneratorsData generatorsData)
    implements Listener {

  /**
   * Handles the EntityExplodeEvent triggered when an entity explodes.
   *
   * @param event The EntityExplodeEvent object representing the entity explode event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onEntityExplode(EntityExplodeEvent event) {
    final List<Block> eventBlock = event.blockList();

    if (eventBlock.stream().anyMatch(block -> locationsData.getGeneratorLocation(block) != null)) {
      event.setCancelled(true);
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\InstantBreak.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import java.util.ArrayList;
import lombok.AllArgsConstructor;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.EquipmentSlot;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

/**
 * Handles the PlayerInteractEvent triggered when a player interacts with a block. If the block is
 * a generator block and the player is sneaking and right-clicks the block, it opens the upgrade
 * GUI.
 */
@AllArgsConstructor
public class InstantBreak implements Listener {

  private final LocationsData locationsData;
  private final GeneratorsData generatorsData;

  /**
   * Handles the PlayerInteractEvent triggered when a player interacts with a block. If the block is
   * a generator block and the player is sneaking and right-clicks the block, it opens the upgrade
   * GUI.
   *
   * @param event The PlayerInteractEvent object representing the player's interaction event.
   */
  @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
  public void onPlayerInteract(PlayerInteractEvent event) {
    if (ServerVersion.isServerVersionAbove(ServerVersion.V1_8)
        && event.getHand() != EquipmentSlot.HAND) {
      return;
    }

    final Player player = event.getPlayer();
    Block block = event.getClickedBlock();

    if (block == null) {
      return;
    }

    if (event.getAction() != Action.LEFT_CLICK_BLOCK || !player.isSneaking()) {
      return;
    }

    final LocationsData.GeneratorLocation generatorLocation =
        locationsData.getGeneratorLocation(block);

    if (generatorLocation == null) {
      return;
    }

    if (generatorLocation.getPlacedBy() != event.getPlayer() && !player.isOp()) {
      Messages.NOT_YOUR_GENERATOR_DESTROY.format().send(event.getPlayer());
      return;
    }

    GeneratorsData.Generator generator =
        generatorsData.getGenerator(generatorLocation.getGenerator());

    if (generator == null) {
      return;
    }

    if (!generator.instantBreak()) {
      return;
    }

    final int tier = generatorLocation.getGenerator();
    ArrayList<Block> blocks = generatorLocation.getBlockLocations();

    block.setType(Material.AIR);

    // Generate and drop the generator item for the player
    if (GensPlus.getInstance().getConfig().getBoolean(Config.INSTANT_PICKUP.getPath())) {
      generator.giveItem(player);
    } else {
      generator.dropItem(event.getPlayer(), block.getLocation());
    }

    blocks.remove(block);

    locationsData.removeLocation(generatorLocation);

    blocks.forEach(generatorBlock -> {
      LocationsData.GeneratorLocation loc = locationsData.getGeneratorLocation(generatorBlock);

      if (loc != null) {
        return;
      }

      locationsData.createLocation(player, tier, generatorBlock);
    });

    // Send a notification to the player
    Messages.SUCCESSFULLY_DESTROYED.format().send(event.getPlayer());
    event.setCancelled(true);
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\OnInventoryClose.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryCloseEvent;
import org.bukkit.inventory.Inventory;
import xyz.arcadiadevs.gensplus.utils.SellUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;

public class OnInventoryClose implements Listener {

  @EventHandler
  public void onInventoryClose(InventoryCloseEvent event) {
    final Inventory inventory = event.getInventory();
    final Player player = (Player) event.getPlayer();

    if (event.getView().getTitle().equals(Config.GUIS_SELL_GUI_TITLE.getString())) {
      SellUtil.sellAll(player, inventory, true);
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\OnInventoryOpen.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import io.github.bananapuncher714.nbteditor.NBTEditor;
import java.util.List;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import xyz.arcadiadevs.gensplus.utils.ItemUtil;

/**
 * The OnInventoryOpen class listens for InventoryOpenEvents.
 */
public class OnInventoryOpen implements Listener {

  /**
   * Sets the tier of a generator drop item in a player's inventory.
   *
   * @param event The InventoryOpenEvent.
   */
  @EventHandler
  public void onInventoryOpen(InventoryOpenEvent event) {
    Player player = (Player) event.getPlayer();

    ItemUtil.upgradeGens(player.getInventory());
    ItemUtil.upgradeGens(event.getInventory());
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\OnJoin.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import lombok.AllArgsConstructor;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.utils.ItemUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;

/**
 * Handles the PlayerJoinEvent triggered when a player joins the server.
 */
@AllArgsConstructor
public class OnJoin implements Listener {

  private final GeneratorsData generatorsData;
  private final PlayerData playerData;
  private final FileConfiguration config;

  /**
   * Handles the PlayerJoinEvent triggered when a player joins the server.
   *
   * @param event The PlayerJoinEvent object representing the player's join event.
   */
  @EventHandler
  public void onJoin(PlayerJoinEvent event) {
    ItemUtil.upgradeGens(event.getPlayer().getInventory());

    if (playerData.getData(event.getPlayer().getUniqueId()) == null) {
      playerData.create(event.getPlayer().getUniqueId(),
          Config.LIMIT_PER_PLAYER_DEFAULT_LIMIT.getInt());
    }

    if (!config.getBoolean(Config.ON_JOIN_ENABLED.getPath())) {
      return;
    }

    if (event.getPlayer().hasPlayedBefore()) {
      return;
    }

    final Player player = event.getPlayer();
    final int tier = Config.ON_JOIN_GENERATOR_TIER.getInt();
    final int amount = Config.ON_JOIN_GENERATOR_AMOUNT.getInt();
    generatorsData.giveItemByTier(player, tier, amount);
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\OnWandUse.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import com.awaitquality.api.spigot.chat.formatter.Formatter;
import com.cryptomorin.xseries.XMaterial;
import io.github.bananapuncher714.nbteditor.NBTEditor;
import lombok.AllArgsConstructor;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.Chest;
import org.bukkit.block.Hopper;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.EquipmentSlot;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import xyz.arcadiadevs.gensplus.models.WandData;
import xyz.arcadiadevs.gensplus.utils.PlayerUtil;
import xyz.arcadiadevs.gensplus.utils.SellUtil;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.List;
import java.util.UUID;

/**
 * The OnWandUse class implements the Listener interface to handle events related to the use of
 * wands in GensPlus.
 */
@AllArgsConstructor
public class OnWandUse implements Listener {

  private final WandData wandData;
  private final FileConfiguration config;

  /**
   * Handles the PlayerInteractEvent triggered when a player right clicks with a wand.
   *
   * @param event The PlayerInteractEvent object representing the player interact event.
   */
  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onWandUse(PlayerInteractEvent event) {

    final Player player = event.getPlayer();

    if (ServerVersion.isServerVersionAbove(ServerVersion.V1_8)
        && event.getHand() != EquipmentSlot.HAND) {
      return;
    }

    Block clickedBlock = event.getClickedBlock();
    ItemStack itemInMainHand = PlayerUtil.getHeldItem(player);

    if (clickedBlock == null) {
      return;
    }

    if (itemInMainHand == null
        || XMaterial.AIR.isSimilar(itemInMainHand)
        || itemInMainHand.getType() == Material.AIR) {
      return;
    }

    if (NBTEditor.contains(itemInMainHand, NBTEditor.CUSTOM_DATA, "sell-wand-uuid")) {
      final boolean needsSneak = Config.SELL_WAND_ACTION_SNEAK.getBoolean();
      final String actionValue = Config.SELL_WAND_ACTION.getString();

      if ((needsSneak && !player.isSneaking())
          || event.getAction() != Action.valueOf(actionValue)) {
        return;
      }

      onSellWandUse(player, itemInMainHand, clickedBlock);
    }
  }

  public void onSellWandUse(Player player, ItemStack itemInMainHand, Block clickedBlock) {
    WandData.Wand wand =
        wandData.getWand(UUID.fromString(NBTEditor.getString(itemInMainHand, NBTEditor.CUSTOM_DATA, "sell-wand-uuid")));

    if ((clickedBlock.getType() == Material.CHEST
        || clickedBlock.getType() == Material.HOPPER)) {

      // Look into the chest or hopper and sell all items
      Inventory inventory = null;
      if (clickedBlock.getType() == Material.CHEST) {
        Chest chest = (Chest) clickedBlock.getState();
        inventory = chest.getInventory();
      } else if (clickedBlock.getType() == Material.HOPPER) {
        Hopper hopper = (Hopper) clickedBlock.getState();
        inventory = hopper.getInventory();
      }

      if (inventory == null) {
        return;
      }

      if (inventory.getContents().length == 0) {
        Messages.NOTHING_TO_SELL.format().send(player);
        return;
      }

      SellUtil.sellWand(player, inventory, wand.getMultiplier(), wand);

      if (wand.getUses() == 0) {
        player.getInventory().remove(itemInMainHand);
        wandData.remove(wand.getUuid());
        Messages.WAND_BROKE.format().send(player);
        return;
      }

      List<String> lore = Formatter.format(wand, config.getStringList("wands.sell-wand.lore"));
      String name = Formatter.format(wand, config.getString("wands.sell-wand.name"));

      ItemMeta meta = itemInMainHand.getItemMeta();
      meta.setLore(lore);
      meta.setDisplayName(name);
      itemInMainHand.setItemMeta(meta);
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\PistonEvent.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import lombok.AllArgsConstructor;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPistonExtendEvent;
import org.bukkit.event.block.BlockPistonRetractEvent;
import xyz.arcadiadevs.gensplus.models.LocationsData;

import java.util.List;

@AllArgsConstructor
public class PistonEvent implements Listener {

  private final LocationsData locationsData;

  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onPistonExtend(BlockPistonExtendEvent event) {
    List<Block> blocks = event.getBlocks();
    for (Block block : blocks) {
      LocationsData.GeneratorLocation generatorLocation = locationsData.getGeneratorLocation(block);
      if (generatorLocation != null) {
        event.setCancelled(true);
        return;
      }
    }
  }

  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
  public void onPistonRetract(BlockPistonRetractEvent event) {
    List<Block> blocks = event.getBlocks();
    for (Block block : blocks) {
      LocationsData.GeneratorLocation generatorLocation = locationsData.getGeneratorLocation(block);
      if (generatorLocation != null) {
        event.setCancelled(true);
        return;
      }
    }
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\SmeltItem.java
================================================================================

package xyz.arcadiadevs.gensplus.events;

import com.cryptomorin.xseries.XMaterial;
import io.github.bananapuncher714.nbteditor.NBTEditor;
import org.bukkit.block.BlockState;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryDragEvent;
import org.bukkit.event.inventory.InventoryMoveItemEvent;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.utils.PlayerUtil;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;
import xyz.arcadiadevs.gensplus.utils.config.Config;

import java.util.Arrays;

/**
 * A listener class for handling events related to smelting items.
 */
public class SmeltItem implements Listener {

  /**
   * Handles inventory click events, preventing interaction with certain items.
   *
   * @param event The inventory click event.
   */
  @EventHandler
  public void onInventoryClick(InventoryClickEvent event) {
    if (Config.CAN_DROPS_BE_USED_IN_SMELTING.getBoolean()) {
      return;
    }

    if (event.getClickedInventory() == null) {
      return;
    }

    if (!isGensItem(event.getCurrentItem())) {
      return;
    }

    InventoryType[] inventoryTypes;

    if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_14)) {
      inventoryTypes = new InventoryType[]{
          InventoryType.FURNACE,
          InventoryType.BLAST_FURNACE,
          InventoryType.SMOKER
      };
    } else {
      inventoryTypes = new InventoryType[]{InventoryType.FURNACE};
    }

    if (!Arrays.asList(inventoryTypes).contains(event.getView().getTopInventory().getType())) {
      return;
    }

    event.setCancelled(true);
  }

  /**
   * Handles hopper transfer events, preventing certain items from being transferred.
   *
   * @param event The inventory move item event.
   */
  @EventHandler
  public void onHopperTransfer(InventoryMoveItemEvent event) {
    if (Config.CAN_DROPS_BE_USED_IN_SMELTING.getBoolean()) {
      return;
    }

    if (event.getSource().getType() == InventoryType.PLAYER) {

      InventoryType[] inventoryTypes;

      if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_14)) {
        inventoryTypes = new InventoryType[]{
            InventoryType.FURNACE,
            InventoryType.BLAST_FURNACE,
            InventoryType.SMOKER
        };
      } else {
        inventoryTypes = new InventoryType[]{InventoryType.FURNACE};
      }

      if (!Arrays.asList(inventoryTypes).contains(event.getDestination().getType())) {
        return;
      }

      InventoryHolder eventHolder = event.getDestination().getHolder();
      if (!(eventHolder instanceof BlockState)) {
        return;
      }

      if (!isGensItem(event.getItem())) {
        return;
      }

      event.setCancelled(true);
    }

    if (event.getSource().getType() == InventoryType.HOPPER) {
      InventoryType[] inventoryTypes;

      if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_14)) {
        inventoryTypes = new InventoryType[]{
            InventoryType.FURNACE,
            InventoryType.BLAST_FURNACE,
            InventoryType.SMOKER
        };
      } else {
        inventoryTypes = new InventoryType[]{InventoryType.FURNACE};
      }

      if (!Arrays.asList(inventoryTypes).contains(event.getDestination().getType())) {
        return;
      }

      event.setCancelled(true);
    }
  }

  /**
   * Handles inventory drag events, preventing certain items from being dragged.
   *
   * @param event The inventory drag event.
   */
  @EventHandler
  public void onInventoryDrag(InventoryDragEvent event) {
    if (Config.CAN_DROPS_BE_USED_IN_SMELTING.getBoolean()) {
      return;
    }

    InventoryType[] inventoryTypes;

    if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_14)) {
      inventoryTypes = new InventoryType[]{
          InventoryType.FURNACE,
          InventoryType.BLAST_FURNACE,
          InventoryType.SMOKER
      };
    } else {
      inventoryTypes = new InventoryType[]{InventoryType.FURNACE};
    }

    if (!Arrays.asList(inventoryTypes).contains(event.getView().getTopInventory().getType())) {
      return;
    }

    event.getRawSlots().forEach(slot -> {
      if (slot < event.getView().getTopInventory().getSize()) {
        if (!isGensItem(event.getOldCursor())) {
          return;
        }

        event.setCancelled(true);
      }
    });

  }

  /**
   * Handles campfire click events, preventing interaction with certain items.
   *
   * @param event The player interact event.
   */
  @EventHandler
  public void onCampfireClick(PlayerInteractEvent event) {
    if (Config.CAN_DROPS_BE_USED_IN_SMELTING.getBoolean()) {
      return;
    }

    if (ServerVersion.isServerVersionBelow(ServerVersion.V1_14)
        || event.getClickedBlock() == null
        || event.getAction() != Action.RIGHT_CLICK_BLOCK) {
      return;
    }

    if (event.getClickedBlock().getType() == XMaterial.SHORT_GRASS.parseMaterial()) {
      return;
    }

    if (XMaterial.CAMPFIRE.parseMaterial()
        != XMaterial.matchXMaterial(event.getClickedBlock().getType()).parseMaterial()) {
      return;
    }

    Player player = event.getPlayer();
    if (isGensItem(PlayerUtil.getHeldItem(player))
        && PlayerUtil.getHeldItem(player) != null
        && PlayerUtil.getHeldItem(player) != XMaterial.AIR.parseItem()) {
      event.setCancelled(true);
    } else if (PlayerUtil.getOffHeldItem(player) != null
        && PlayerUtil.getOffHeldItem(player) != XMaterial.AIR.parseItem()) {
      event.setCancelled(true);
    }
  }

  /**
   * Checks if an item is a gens item based on its NBT tags.
   *
   * @param item The item to check.
   * @return True if the item is a gens item, otherwise false.
   */
  private boolean isGensItem(ItemStack item) {
    if (item == null || item.getType() == XMaterial.AIR.parseMaterial()) {
      return false;
    }

    return NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")
        || NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "blocktype", "tier");
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\skyblock\Bentobox.java
================================================================================

package xyz.arcadiadevs.gensplus.events.skyblock;

import java.util.List;
import lombok.AllArgsConstructor;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import world.bentobox.bentobox.api.events.island.IslandDeleteEvent;
import xyz.arcadiadevs.gensplus.models.LocationsData;

@AllArgsConstructor
public class Bentobox implements Listener {

  private LocationsData locationsData;

  @EventHandler
  public void onIslandRemoveBentoBox(IslandDeleteEvent event) {
    List<LocationsData.GeneratorLocation> locations = locationsData.locations();
    locations.removeIf(location ->
        location.getIslandId().equals(event.getIsland().getUniqueId()));
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\events\skyblock\IridiumSkyblock.java
================================================================================

package xyz.arcadiadevs.gensplus.events.skyblock;

import com.iridium.iridiumskyblock.api.IslandDeleteEvent;
import java.util.List;
import lombok.AllArgsConstructor;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import xyz.arcadiadevs.gensplus.models.LocationsData;

@AllArgsConstructor
public class IridiumSkyblock implements Listener {

  private LocationsData locationsData;

  @EventHandler
  public void onIslandRemoveIridium(IslandDeleteEvent event) {
    List<LocationsData.GeneratorLocation> locations = locationsData.locations();
    locations.removeIf(location ->
        location.getIslandId().equals(String.valueOf(event.getIsland().getId())));
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\guis\GeneratorsGui.java
================================================================================

package xyz.arcadiadevs.gensplus.guis;

import com.awaitquality.api.spigot.chat.ChatUtil;
import com.cryptomorin.xseries.XMaterial;
import com.cryptomorin.xseries.XSound;
import net.milkbowl.vault.economy.Economy;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.utils.GuiUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;
import xyz.arcadiadevs.guilib.Gui;
import xyz.arcadiadevs.guilib.GuiItem;
import xyz.arcadiadevs.guilib.GuiItemType;
import xyz.arcadiadevs.guilib.ItemBuilder;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * The GeneratorsGui class provides functionality for opening the generators GUI in GensPlus.
 * It displays a GUI menu containing buttons representing different generators.
 */
public class GeneratorsGui {

  /**
   * Opens the generators GUI for the specified player.
   *
   * @param player The Player object for whom the GUI is being opened.
   */
  public static void open(Player player) {
    final var instance = GensPlus.getInstance();
    final var config = instance.getConfig();
    final Economy economy = instance.getEcon();

    if (!config.getBoolean(Config.GUIS_GENERATORS_GUI_ENABLED.getPath())) {
      return;
    }

    final var rows = config.getInt(Config.GUIS_GENERATORS_GUI_ROWS.getPath());

    final var menu = new Gui(
        ChatUtil.translate(config.getString(Config.GUIS_GENERATORS_GUI_TITLE.getPath())),
        rows,
        instance
    );

    GeneratorsData generatorsData = instance.getGeneratorsData();
    List<Map<?, ?>> generatorsConfig = config.getMapList(Config.GENERATORS.getPath());

    for (GeneratorsData.Generator generator : generatorsData.getGenerators()) {
      final ItemStack material = new ItemStack(generator.blockType());

      Map<?, ?> matchingGeneratorConfig = generatorsConfig.stream()
          .filter(generatorConfig -> generatorConfig.get("name").equals(generator.name()))
          .findFirst()
          .orElse(null);

      if (matchingGeneratorConfig == null) {
        continue;
      }

      List<String> lore = ((List<String>) matchingGeneratorConfig.get("lore")).isEmpty()
          ? config.getStringList("default-lore")
          : (List<String>) matchingGeneratorConfig.get("lore");

      lore = lore.stream()
          .map(s -> s.replace("%tier%", String.valueOf(generator.tier())))
          .map(s -> s.replace("%speed%", String.valueOf(generator.speed())))
          .map(s -> s.replace("%price%", economy.format(generator.price())))
          .map(s -> s.replace("%sellPrice%", economy.format(generator.sellPrice())))
          .map(s -> s.replace("%spawnItem%", generator.spawnItem().getType().name()))
          .map(s -> s.replace("%blockType%", generator.blockType().getType().name()))
          .map(ChatUtil::translate)
          .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);

      final var itemBuilder = new ItemBuilder(material)
          .name(ChatUtil.translate(generator.name()))
          .lore(lore)
          .build();

      if ((Config.GUIS_GENERATORS_GUI_BORDER_ENABLED.getBoolean())) {
        GuiUtil.addBorder(menu, Config.GUIS_GENERATORS_GUI_BORDER_MATERIAL.getString());
      }

      Material nextPageMaterial = XMaterial.matchXMaterial(
          Config.GUIS_GENERATORS_GUI_NEXT_PAGE_MATERIAL.getString())
          .orElse(XMaterial.ARROW)
          .parseMaterial();

      Material previousPageMaterial = XMaterial.matchXMaterial(
          Config.GUIS_GENERATORS_GUI_PREVIOUS_PAGE_MATERIAL.getString())
          .orElse(XMaterial.ARROW)
          .parseMaterial();

      Material closeButtonMaterial = XMaterial.matchXMaterial(
          Config.GUIS_GENERATORS_GUI_CLOSE_BUTTON_MATERIAL.getString())
          .orElse(XMaterial.BARRIER)
          .parseMaterial();

      ItemStack nextPage = new ItemBuilder(nextPageMaterial)
          .name(ChatUtil.translate("&aNext Page"))
          .build();

      ItemStack previousPage = new ItemBuilder(previousPageMaterial)
          .name(ChatUtil.translate("&aPrevious Page"))
          .build();

      ItemStack closeButton = new ItemBuilder(closeButtonMaterial)
          .name(ChatUtil.translate("&cClose"))
          .build();

      menu.setItem(((rows - 1) * 9) + 3, new GuiItem(GuiItemType.PREVIOUS, previousPage, null));
      menu.setItem(((rows - 1) * 9) + 4, new GuiItem(GuiItemType.CLOSE, closeButton, null));
      menu.setItem(((rows - 1) * 9) + 5, new GuiItem(GuiItemType.NEXT, nextPage, null));

      String playerBalance = economy.format(economy.getBalance(player));

      menu.addItem(new GuiItem(GuiItemType.ITEM, itemBuilder, () -> {
        if (generator.price() > economy.getBalance(player)) {
          Messages.NOT_ENOUGH_MONEY.format(
              "currentBalance", playerBalance,
              "price", economy.currencyNameSingular() + generator.price())
              .send(player);

          XSound.ENTITY_VILLAGER_NO.play(player);
          return;
        }

        generator.giveItem(player);

        economy.withdrawPlayer(player, generator.price());

        Messages.SUCCESSFULLY_BOUGHT.format(
                "generator", generator.name(),
                "tier", generator.tier(),
                "price", generator.price())
            .send(player);

        XSound.ENTITY_PLAYER_LEVELUP.play(player);
      }));

    }

    player.openInventory(menu.getInventory());
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\guis\ListGui.java
================================================================================

package xyz.arcadiadevs.gensplus.guis;

import com.awaitquality.api.spigot.chat.ChatUtil;
import com.cryptomorin.xseries.XMaterial;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.OfflinePlayer;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.utils.LimitUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.guilib.Gui;
import xyz.arcadiadevs.guilib.GuiItem;
import xyz.arcadiadevs.guilib.GuiItemType;
import xyz.arcadiadevs.guilib.ItemBuilder;

import java.util.ArrayList;
import java.util.List;

public class ListGui {

  public static void open(Player player) {
    final var instance = GensPlus.getInstance();

    final var menu = new Gui(
        ChatUtil.translate("List of Players"),
        6,
        instance
    );

    Material nextPageMaterial = XMaterial.matchXMaterial(
            Config.GUIS_GENERATORS_GUI_NEXT_PAGE_MATERIAL.getString())
        .orElse(XMaterial.ARROW)
        .parseMaterial();

    Material previousPageMaterial = XMaterial.matchXMaterial(
            Config.GUIS_GENERATORS_GUI_PREVIOUS_PAGE_MATERIAL.getString())
        .orElse(XMaterial.ARROW)
        .parseMaterial();

    Material closeButtonMaterial = XMaterial.matchXMaterial(
            Config.GUIS_GENERATORS_GUI_CLOSE_BUTTON_MATERIAL.getString())
        .orElse(XMaterial.BARRIER)
        .parseMaterial();


    ItemStack nextPage = new ItemBuilder(nextPageMaterial)
        .name(ChatUtil.translate("&aNext Page"))
        .build();

    ItemStack previousPage = new ItemBuilder(previousPageMaterial)
        .name(ChatUtil.translate("&aPrevious Page"))
        .build();

    ItemStack closeButton = new ItemBuilder(closeButtonMaterial)
        .name(ChatUtil.translate("&cClose"))
        .build();


    menu.setItem(((6 - 1) * 9) + 3, new GuiItem(GuiItemType.PREVIOUS, previousPage, null));
    menu.setItem(((6 - 1) * 9) + 4, new GuiItem(GuiItemType.CLOSE, closeButton, null));
    menu.setItem(((6 - 1) * 9) + 5, new GuiItem(GuiItemType.NEXT, nextPage, null));

    PlayerData playerData = instance.getPlayerData();

    for (OfflinePlayer p : instance.getServer().getOnlinePlayers()) {
      int combinedLimit = LimitUtil.calculateCombinedLimit(p, playerData);

      List<String> lore = new ArrayList<>();
      lore.add(ChatUtil.translate("&7Placed: &e" + instance.getLocationsData().getGeneratorsCountByPlayer(p.getPlayer())));
      lore.add(ChatUtil.translate("&7Limit: &e" + combinedLimit));
      lore.add(ChatUtil.translate("&7Click to view generators"));

      final var itemBuilder = new ItemBuilder(XMaterial.PLAYER_HEAD.parseMaterial())
          .name(ChatUtil.translate(p.getName()))
          .lore(lore)
          .skullOwner(p.getName())
          .build();

      menu.addItem(new GuiItem(GuiItemType.ITEM, itemBuilder, () -> {
        generatorListForPlayer(player, p.getPlayer());
      }));
    }

    player.getPlayer().openInventory(menu.getInventory());
  }

  private static void generatorListForPlayer(Player player, OfflinePlayer targetPlayer) {
    final var instance = GensPlus.getInstance();

    final var menu = new Gui(
        ChatUtil.translate("List of Generators for " + targetPlayer.getName()),
        6,
        instance
    );

    Material nextPageMaterial = XMaterial.matchXMaterial(
            Config.GUIS_GENERATORS_GUI_NEXT_PAGE_MATERIAL.getString())
        .orElse(XMaterial.ARROW)
        .parseMaterial();

    Material previousPageMaterial = XMaterial.matchXMaterial(
            Config.GUIS_GENERATORS_GUI_PREVIOUS_PAGE_MATERIAL.getString())
        .orElse(XMaterial.ARROW)
        .parseMaterial();

    Material closeButtonMaterial = XMaterial.matchXMaterial(
            Config.GUIS_GENERATORS_GUI_CLOSE_BUTTON_MATERIAL.getString())
        .orElse(XMaterial.BARRIER)
        .parseMaterial();


    ItemStack nextPage = new ItemBuilder(nextPageMaterial)
        .name(ChatUtil.translate("&aNext Page"))
        .build();

    ItemStack previousPage = new ItemBuilder(previousPageMaterial)
        .name(ChatUtil.translate("&aPrevious Page"))
        .build();

    ItemStack closeButton = new ItemBuilder(closeButtonMaterial)
        .name(ChatUtil.translate("&cClose"))
        .build();


    menu.setItem(((6 - 1) * 9) + 3, new GuiItem(GuiItemType.PREVIOUS, previousPage, null));
    menu.setItem(((6 - 1) * 9) + 4, new GuiItem(GuiItemType.CLOSE, closeButton, null));
    menu.setItem(((6 - 1) * 9) + 5, new GuiItem(GuiItemType.NEXT, nextPage, null));

    instance.getLocationsData()
        .locations()
        .stream()
        .filter(location -> location.getPlacedBy().equals(targetPlayer))
        .forEach(location -> {
          ItemStack locationItem = new ItemStack(location.getGeneratorObject().blockType());
          ItemMeta meta = locationItem.getItemMeta();
          meta.setDisplayName(ChatUtil.translate(location.getCenter().getBlockX() + ", " + location.getCenter().getBlockY() + ", " + location.getCenter().getBlockZ()));
          locationItem.setItemMeta(meta);

          menu.addItem(new GuiItem(GuiItemType.ITEM, locationItem, () -> {
            openInside(player.getPlayer(), location);
          }));
        });

    player.getPlayer().openInventory(menu.getInventory());
  }

  private static void openInside(OfflinePlayer player, LocationsData.GeneratorLocation locations) {
    final var instance = GensPlus.getInstance();

    final var menu = new Gui(
        ChatUtil.translate("List of Generators for " + player.getName()),
        6,
        instance
    );

    locations.getBlockLocations().forEach(location -> {
      ItemStack locationItem = new ItemStack(locations.getGeneratorObject().blockType());
      Location finalLocation = location.getLocation();
      locationItem.setItemMeta(null);
      ItemMeta meta = locationItem.getItemMeta();
      meta.setDisplayName(ChatUtil.translate("&7Click to choose an option"));
      meta.setLore(List.of(
          ChatUtil.translate("&7Name: " + locations.getGeneratorObject().name()),
          ChatUtil.translate("&7Tier: " + locations.getGeneratorObject().tier()),
          ChatUtil.translate("&7X: " + finalLocation.getBlockX()),
          ChatUtil.translate("&7Y: " + finalLocation.getBlockY()),
          ChatUtil.translate("&7Z: " + finalLocation.getBlockZ())
      ));
      locationItem.setItemMeta(meta);

      menu.addItem(new GuiItem(GuiItemType.ITEM, locationItem, () -> {
        chooseOption(player.getPlayer(), location.getLocation());
      }));
    });

    player.getPlayer().openInventory(menu.getInventory());
  }

  private static void chooseOption(OfflinePlayer player, Location finalLocation) {
    final var instance = GensPlus.getInstance();

    final var menu = new Gui(
        ChatUtil.translate("Choose an Option"),
        3,
        instance
    );

    ItemStack teleportItem = new ItemStack(XMaterial.ENDER_PEARL.parseItem());
    ItemMeta meta = teleportItem.getItemMeta();
    meta.setDisplayName(ChatUtil.translate("Teleport to Generator"));
    teleportItem.setItemMeta(meta);
    menu.addItem(new GuiItem(GuiItemType.ITEM, teleportItem, () -> {
      player.getPlayer().teleport(finalLocation.add(0.5, 1, 0.5));
    }));

    ItemStack removeItem = new ItemStack(XMaterial.TNT.parseItem());
    meta = removeItem.getItemMeta();
    meta.setDisplayName(ChatUtil.translate("Remove Generator"));
    removeItem.setItemMeta(meta);
    menu.addItem(new GuiItem(GuiItemType.ITEM, removeItem, () -> {
      final Block eventBlock = finalLocation.getBlock();
      final LocationsData.GeneratorLocation generatorLocation =
          instance.getLocationsData().getGeneratorLocation(eventBlock);

      if (generatorLocation == null) {
        return;
      }

      final int tier = generatorLocation.getGenerator();
      ArrayList<Block> blocks = generatorLocation.getBlockLocations();

      blocks.remove(eventBlock);

      instance.getLocationsData().removeLocation(generatorLocation);

      blocks.forEach(block -> {
        LocationsData.GeneratorLocation loc = instance.getLocationsData().getGeneratorLocation(block);

        if (loc != null) {
          return;
        }

        instance.getLocationsData().createLocation(player, tier, block);
      });

      finalLocation.getBlock().setType(XMaterial.AIR.parseMaterial());

      player.getPlayer().sendMessage(ChatUtil.translate("&aGenerator removed!"));
      player.getPlayer().closeInventory();
    }));

    player.getPlayer().openInventory(menu.getInventory());
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\guis\SellGui.java
================================================================================

package xyz.arcadiadevs.gensplus.guis;

import com.awaitquality.api.spigot.chat.ChatUtil;
import org.bukkit.entity.Player;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.guilib.Gui;

public class SellGui {

  public static void open(Player player) {
    if (!Config.GUIS_SELL_GUI_ENABLED.getBoolean()) {
      return;
    }

    final GensPlus instance = GensPlus.getInstance();
    final int rows = Config.GUIS_SELL_GUI_ROWS.getInt();

    final Gui menu = new Gui(
        ChatUtil.translate(Config.GUIS_SELL_GUI_TITLE.getString()),
        rows,
        instance
    );

    player.openInventory(menu.getInventory());
  }
}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\guis\UpgradeGui.java
================================================================================

package xyz.arcadiadevs.gensplus.guis;

import com.awaitquality.api.spigot.chat.ChatUtil;
import com.cryptomorin.xseries.XSound;
import net.milkbowl.vault.economy.Economy;
import net.milkbowl.vault.economy.EconomyResponse;
import org.bukkit.Location;
import org.bukkit.Particle;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.utils.GuiUtil;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;
import xyz.arcadiadevs.guilib.Gui;
import xyz.arcadiadevs.guilib.GuiItem;
import xyz.arcadiadevs.guilib.GuiItemType;

import java.util.ArrayList;
import java.util.List;

/**
 * The UpgradeGui class provides functionality for opening the upgrade GUI for generators in
 * GensPlus. It allows players to upgrade their generators to the next tier.
 */
public class UpgradeGui {
  private static final GensPlus instance = GensPlus.getInstance();
  private static final Economy economy = instance.getEcon();
  private static final FileConfiguration config = instance.getConfig();

  /**
   * Opens the upgrade GUI for the specified player and generator.
   *
   * @param player    The Player object for whom the GUI is being opened.
   * @param generator The GeneratorLocation representing the generator to be upgraded.
   */
  public static void open(Player player, LocationsData.GeneratorLocation generator,
                          Block clickedBlock) {
    if (generator.getPlacedBy() != player
        && !player.hasPermission(Permissions.ADMIN.getPermission())
        && !player.isOp()) {
      Messages.NOT_YOUR_GENERATOR_UPGRADE.format().send(player);
      return;
    }

    final var rows = Config.GUIS_UPGRADE_GUI_ROWS.getInt();
    final var menu = new Gui(
        ChatUtil.translate(config.getString(Config.GUIS_UPGRADE_GUI_TITLE.getPath())),
        rows,
        instance
    );

    final GeneratorsData.Generator current = generator.getGeneratorObject();
    GeneratorsData.Generator nextGenerator =
        instance.getGeneratorsData().getGenerator(current.tier() + 1);

    if (nextGenerator == null) {
      Messages.REACHED_MAX_TIER.format().send(player);
      return;
    }

    final ItemStack itemStackUpgradeOne = new ItemStack(nextGenerator.blockType());
    final ItemMeta itemMetaUpgradeOne = itemStackUpgradeOne.getItemMeta();

    itemMetaUpgradeOne.setDisplayName(ChatUtil.translate(config.getString(
        Config.GUIS_UPGRADE_GUI_UPGRADE_ONE_FIRST_LINE.getPath()))
    );

    double price = instance.getGeneratorsData().getUpgradePrice(current, nextGenerator.tier());

    List<String> lore =
        config.getStringList(Config.GUIS_UPGRADE_GUI_UPGRADE_ONE_LORE.getPath());

    lore = lore.stream()
        .map(s -> s.replace("%tier%", String.valueOf(current.tier())))
        .map(s -> s.replace("%speed%", String.valueOf(current.speed())))
        .map(s -> s.replace("%price%", economy.format(current.price())))
        .map(s -> s.replace("%sellPrice%", economy.format(current.sellPrice())))
        .map(s -> s.replace("%spawnItem%", current.spawnItem().getType().name()))
        .map(s -> s.replace("%blockType%", current.blockType().getType().name()))
        .map(s -> s.replace("%nextTier%", String.valueOf(nextGenerator.tier())))
        .map(s -> s.replace("%nextSpeed%", String.valueOf(nextGenerator.speed())))
        .map(s -> s.replace("%nextPrice%", economy.format(nextGenerator.price())))
        .map(s -> s.replace("%nextSellPrice%", economy.format(nextGenerator.sellPrice())))
        .map(s -> s.replace("%nextSpawnItem%", nextGenerator.spawnItem().getType().name()))
        .map(s -> s.replace("%nextBlockType%", nextGenerator.blockType().getType().name()))
        .map(s -> s.replace("%upgradePrice%", economy.format(price)))
        .map(s -> s.replace("%money%", economy.format(economy.getBalance(player))))
        .map(ChatUtil::translate)
        .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);

    itemMetaUpgradeOne.setLore(lore);
    itemStackUpgradeOne.setItemMeta(itemMetaUpgradeOne);

    final ItemStack itemStackUpgradeAll = new ItemStack(nextGenerator.blockType());
    final ItemMeta itemMetaUpgradeAll = itemStackUpgradeAll.getItemMeta();

    itemMetaUpgradeAll.setDisplayName(ChatUtil.translate(config.getString(
        Config.GUIS_UPGRADE_GUI_UPGRADE_ALL_FIRST_LINE.getPath()))
    );

    List<String> loreAll =
        config.getStringList(Config.GUIS_UPGRADE_GUI_UPGRADE_ALL_LORE.getPath());

    double priceForAll = price * generator.getBlockLocations().size();
    loreAll = loreAll.stream()
        .map(s -> s.replace("%tier%", String.valueOf(current.tier())))
        .map(s -> s.replace("%speed%", String.valueOf(current.speed())))
        .map(s -> s.replace("%price%", economy.format(current.price())))
        .map(s -> s.replace("%sellPrice%", economy.format(current.sellPrice())))
        .map(s -> s.replace("%spawnItem%", current.spawnItem().getType().name()))
        .map(s -> s.replace("%blockType%", current.blockType().getType().name()))
        .map(s -> s.replace("%nextTier%", String.valueOf(nextGenerator.tier())))
        .map(s -> s.replace("%nextSpeed%", String.valueOf(nextGenerator.speed())))
        .map(s -> s.replace("%nextPrice%", economy.format(nextGenerator.price())))
        .map(s -> s.replace("%nextSellPrice%", economy.format(nextGenerator.sellPrice())))
        .map(s -> s.replace("%nextSpawnItem%", nextGenerator.spawnItem().getType().name()))
        .map(s -> s.replace("%nextBlockType%", nextGenerator.blockType().getType().name()))
        .map(s -> s.replace("%upgradePrice%", economy.format(priceForAll)))
        .map(s -> s.replace("%money%", economy.format(economy.getBalance(player))))
        .map(ChatUtil::translate)
        .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);

    itemMetaUpgradeAll.setLore(loreAll);
    itemStackUpgradeAll.setItemMeta(itemMetaUpgradeAll);

    final List<String> itemFill = economy.has(player, price)
        ? List.of("ORANGE_STAINED_GLASS_PANE", "LIME_STAINED_GLASS_PANE")
        : List.of("ORANGE_STAINED_GLASS_PANE", "RED_STAINED_GLASS_PANE");

    GuiUtil.fillWithRandom(menu, itemFill);

    menu.setItem(11, new GuiItem(GuiItemType.ITEM, itemStackUpgradeOne, () -> {
      upgradeGenerator(player, generator, clickedBlock);
      player.closeInventory();
    }));

    menu.setItem(15, new GuiItem(GuiItemType.ITEM, itemStackUpgradeAll, () -> {
      upgradeAllGenerators(player, generator, clickedBlock);
      player.closeInventory();
    }));

    player.openInventory(menu.getInventory());
  }

  /**
   * Upgrades the specified generator to the next tier for the given player.
   *
   * @param player     The Player object who is upgrading the generator.
   * @param currentLoc The GeneratorLocation representing the generator to be upgraded.
   */
  private static void upgradeAllGenerators(Player player,
                                           LocationsData.GeneratorLocation currentLoc,
                                           Block clickedBlock) {
    final LocationsData locationsData = instance.getLocationsData();
    GeneratorsData.Generator current = currentLoc.getGeneratorObject();
    GeneratorsData.Generator nextGenerator =
        instance.getGeneratorsData().getGenerator(current.tier() + 1);

    if (nextGenerator == null) {
      Messages.REACHED_MAX_TIER.format().send(player);
      return;
    }

    double upgradePrice =
        instance.getGeneratorsData().getUpgradePrice(current, nextGenerator.tier())
            * currentLoc.getBlockLocations().size();

    if (upgradePrice > instance.getEcon().getBalance(player)) {
      Messages.NOT_ENOUGH_MONEY.format(
              "currentBalance", instance.getEcon().getBalance(player),
              "price", instance.getEcon().format(upgradePrice))
          .send(player);

      XSound.ENTITY_VILLAGER_NO.play(player);
      return;
    }

    EconomyResponse response = instance.getEcon().withdrawPlayer(player, upgradePrice);

    if (!response.transactionSuccess()) {
      player.sendMessage(ChatUtil.translate(
          "Sorry, we were unable to process your transaction. Reason: "
              + response.errorMessage));
      return;
    }

    LocationsData.GeneratorLocation next = currentLoc.getNextTier();

    currentLoc.getBlockLocations()
        .forEach(blockLoc -> blockLoc.setType(nextGenerator.blockType().getType()));

    locationsData.removeLocation(currentLoc);

    locationsData.addLocation(next);

    spawnFirework(currentLoc.getCenter());

    Messages.SUCCESSFULLY_UPGRADED.format("tier", nextGenerator.tier()).send(player);
  }

  /**
   * Upgrades the specified generator to the next tier for the given player.
   *
   * @param player       The Player object who is upgrading the generator.
   * @param currentLoc   The GeneratorLocation representing the generator to be upgraded.
   * @param clickedBlock The Block object that was clicked to open the upgrade GUI.
   */
  public static void upgradeGenerator(Player player, LocationsData.GeneratorLocation currentLoc,
                                      Block clickedBlock) {
    final LocationsData locationsData = instance.getLocationsData();
    final GeneratorsData.Generator current = currentLoc.getGeneratorObject();
    final GeneratorsData.Generator nextGenerator =
        instance.getGeneratorsData().getGenerator(current.tier() + 1);

    if (nextGenerator == null) {
      Messages.REACHED_MAX_TIER.format().send(player);
      return;
    }

    double upgradePrice =
        instance.getGeneratorsData().getUpgradePrice(current, nextGenerator.tier());

    if (upgradePrice > instance.getEcon().getBalance(player)) {
      Messages.NOT_ENOUGH_MONEY.format(
              "currentBalance", instance.getEcon().getBalance(player),
              "price", instance.getEcon().format(upgradePrice))
          .send(player);

      XSound.ENTITY_VILLAGER_NO.play(player);
      return;
    }

    EconomyResponse response = instance.getEcon().withdrawPlayer(player, upgradePrice);

    if (!response.transactionSuccess()) {
      player.sendMessage(ChatUtil.translate(
          "Sorry, we were unable to process your transaction. Reason: "
              + response.errorMessage));
      return;
    }

    ArrayList<Block> blocks = currentLoc.getBlockLocations();
    blocks.remove(clickedBlock);

    locationsData.removeLocation(currentLoc);

    blocks.forEach(block -> {
      LocationsData.GeneratorLocation loc = locationsData.getGeneratorLocation(block);

      if (loc != null) {
        return;
      }

      locationsData.createLocation(player, currentLoc.getGenerator(), block);
    });

    locationsData.createLocation(player, currentLoc.getGenerator() + 1, clickedBlock);

    clickedBlock.setType(nextGenerator.blockType().getType());

    spawnFirework(currentLoc.getCenter());

    Messages.SUCCESSFULLY_UPGRADED.format("tier", nextGenerator.tier()).send(player);
  }

  private static void spawnFirework(Location location) {
    FileConfiguration config = GensPlus.getInstance().getConfig();
    XSound.matchXSound(config.getString(Config.PARTICLES_SOUND.getPath()))
        .orElse(XSound.ENTITY_FIREWORK_ROCKET_BLAST)
        .play(location);

    if (!config.getBoolean(Config.PARTICLES_ENABLED.getPath())) {
      return;
    }

    String particle = config.getString(Config.PARTICLES_TYPE.getPath());

    // TODO: Fix 1.8 support
    if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_9)) {
      location.getWorld()
          .spawnParticle(
              Particle.valueOf(particle),
              location.add(0, -1, 0),
              70
          );
    }
  }
}




================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\GeneratorsData.java
================================================================================

package xyz.arcadiadevs.gensplus.models;

import lombok.Getter;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.utils.ActionBarUtil;

import java.util.List;
import java.util.NoSuchElementException;

/**
 * The GeneratorsData class represents the data for generators in GensPlus. It contains a list
 * of generators and provides methods to retrieve generator information and calculate upgrade
 * prices.
 */
public record GeneratorsData(@Getter List<Generator> generators) {

  /**
   * Retrieves the generator with the specified tier.
   *
   * @param tier The tier of the generator.
   * @return The Generator object corresponding to the specified tier, or null if not found.
   */
  public Generator getGenerator(int tier) {
    return generators.stream()
        .filter(generator -> generator.tier() == tier)
        .findFirst()
        .orElse(null);
  }

  /**
   * Calculates the upgrade price from the current generator to the specified new tier.
   *
   * @param generator The current generator.
   * @param newTier   The new tier to upgrade to.
   * @return The upgrade price from the current generator to the new tier.
   * @throws NoSuchElementException if no generator with the new tier is found.
   */
  public double getUpgradePrice(Generator generator, int newTier) throws NoSuchElementException {
    return generators.stream()
        .filter(g -> g.tier() == newTier)
        .findFirst()
        .map(nextTierGen -> nextTierGen.price() - generator.price())
        .orElseThrow();
  }

  /**
   * Calculates the sell price of the specified generator.
   *
   * @param player The player who is selling the generator.
   * @param tier   The tier of the generator.
   */
  public void giveItemByTier(Player player, int tier, int amount) {
    Generator generator = getGenerator(tier);
    ItemStack item = new ItemStack(generator.blockType());
    item.setAmount(amount);
    player.getInventory().addItem(item);
  }

  /**
   * The Generator record represents a generator in GensPlus. It contains various properties
   * such as name, tier, price, sell price, speed, items, and lore.
   */
  public record Generator(String name, int tier, double price, double sellPrice, int speed,
                          ItemStack spawnItem, ItemStack blockType, List<String> lore,
                          boolean instantBreak) {

    /**
     * Gives the generator's block item to the specified player.
     *
     * @param player The player to give the item to.
     */
    public void giveItem(Player player) {
      if (player.getInventory().firstEmpty() == -1) {
        ActionBarUtil.sendActionBar(player, "&cYour inventory is full!");
        player.getWorld().dropItemNaturally(player.getLocation(), blockType);
        return;
      }

      player.getInventory().addItem(blockType);
    }

    /**
     * Drops the generator's block item naturally at the location of the specified block break
     * event.
     *
     * @param player   The player who broke the block.
     * @param location The location of the block.
     */
    public void dropItem(Player player, Location location) {
      player.getWorld().dropItemNaturally(location, blockType);
    }

    @Override
    public String toString() {
      return "Generator{"
          + "name='" + name + '\''
          + ", tier=" + tier
          + '}';
    }
  }

}




================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\LocationsData.java
================================================================================

package xyz.arcadiadevs.gensplus.models;

import com.awaitquality.api.spigot.chat.ChatUtil;
import com.cryptomorin.xseries.XMaterial;
import lombok.Getter;
import lombok.Setter;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.util.Vector;
import org.holoeasy.hologram.Hologram;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.events.DropEvent;
import xyz.arcadiadevs.gensplus.models.location.SimplifiedLocation;
import xyz.arcadiadevs.gensplus.tasks.EventLoop;
import xyz.arcadiadevs.gensplus.utils.HologramsUtil;
import xyz.arcadiadevs.gensplus.utils.PlayerUtil;
import xyz.arcadiadevs.gensplus.utils.SkyblockUtil;
import xyz.arcadiadevs.gensplus.utils.TimeUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Represents the data of all the generator locations in the server.
 */
public record LocationsData(CopyOnWriteArrayList<GeneratorLocation> locations) {

  private static final Map<Block, GeneratorLocation> locationMap = new ConcurrentHashMap<>();

  public LocationsData(CopyOnWriteArrayList<GeneratorLocation> locations) {
    this.locations = locations;
    // Initialize the locationMap
    locations.forEach(location -> location.getBlockLocations().forEach(block -> locationMap.put(block, location)));
  }

  public Integer getGeneratorsCountByPlayer(Player player) {
    return (int) locations.stream()
        .filter(l -> l.getPlacedBy().equals(player))
        .mapToLong(l -> l.getBlockLocations().size())
        .sum();
  }

  public Integer getGeneratorsCountByIsland(String id) {
    return (int) locations.stream()
        .filter(l -> l.islandId != null && l.islandId.equals(id))
        .mapToLong(l -> l.getBlockLocations().size())
        .sum();
  }

  /**
   * Creates a new generator location for generator.
   *
   * @param player        The player who placed the generator.
   * @param generator     The generator tier.
   * @param blockLocation The location of the generator.
   */
  public GeneratorLocation createLocation(OfflinePlayer player, int generator,
                                          Block blockLocation) {
    if (Config.DEVELOPER_OPTIONS.getBoolean()) {
      GensPlus.getInstance().getLogger().info("[DEBUG] Creating generator location:");
      GensPlus.getInstance().getLogger().info("[DEBUG] Player: " + player.getName());
      GensPlus.getInstance().getLogger().info("[DEBUG] Generator tier: " + generator);
      GensPlus.getInstance().getLogger().info("[DEBUG] Location: " + blockLocation.getLocation());
    }

    GeneratorLocation[] surroundingBlocks = {
        getGeneratorLocation(blockLocation.getRelative(0, 1, 0)),
        getGeneratorLocation(blockLocation.getRelative(0, -1, 0)),
        getGeneratorLocation(blockLocation.getRelative(-1, 0, 0)),
        getGeneratorLocation(blockLocation.getRelative(1, 0, 0)),
        getGeneratorLocation(blockLocation.getRelative(0, 0, -1)),
        getGeneratorLocation(blockLocation.getRelative(0, 0, 1))
    };


    List<GeneratorLocation> surroundingLocations = Stream.of(surroundingBlocks)
        .filter(Objects::nonNull)
        .filter(l -> l.getGenerator() == generator)
        .filter(l -> l.getPlacedBy().equals(player))
        .toList();

    // remove all surrounding locations from the list
    removeAll(surroundingLocations);

    HashSet<Block> generatorBlocks = surroundingLocations.stream()
        .flatMap(l -> l.getBlockLocations().stream())
        .collect(Collectors.toCollection(HashSet::new));

    generatorBlocks.add(blockLocation);

    GeneratorLocation newLocation = new GeneratorLocation(
        player.getUniqueId().toString(),
        SkyblockUtil.getIslandId(blockLocation.getLocation()),
        generator,
        new ArrayList<>(generatorBlocks)
    );

    addLocation(newLocation);

    return newLocation;
  }

  public void addLocation(GeneratorLocation location) {
    locations.add(location);
    location.getBlockLocations().forEach(block -> locationMap.put(block, location));
  }

  /**
   * Removes generator location.
   *
   * @param location The generator location to remove.
   */
  public void removeLocation(GeneratorLocation location) {
    try {
      location.getBlockLocations().forEach(locationMap::remove);

      if (Config.HOLOGRAMS_ENABLED.getBoolean()) {
        HologramsUtil.removeHologram(location.getHologram());
      }
      locations.remove(location);
      location.getBlockLocations().forEach(locationMap::remove);
    } catch (Exception e) {
      if (Config.DEVELOPER_OPTIONS.getBoolean()) {
        e.printStackTrace();
      }
    }
  }

  public void removeAll(List<GeneratorLocation> locations) {
    locations.forEach(this::removeLocation);
  }

  /**
   * Gets the generator location by the block location.
   *
   * @param location The block location.
   * @return The generator location.
   */
  public GeneratorLocation getGeneratorLocation(Block location) {
    return locationMap.get(location);
  }

  /**
   * Represents a generator location.
   */
  @Getter
  public static class GeneratorLocation {

    private final String playerId;

    @Setter
    private String islandId;

    private final Integer generator;

    private final ArrayList<SimplifiedLocation> blockLocations;

    @Setter
    private transient String hologramId;

    /**
     * Represents a generator location.
     */
    @SuppressWarnings("unchecked")
    public GeneratorLocation(String playerId, String islandId, Integer generator,
                             List<?> blockLocations) {
      this.playerId = playerId;
      this.generator = generator;
      this.islandId = islandId;

      if (blockLocations.get(0) instanceof Block) {
        // Perform actions specific to Block
        this.blockLocations = blockLocations.stream()
            .map(b -> SimplifiedLocation.fromLocation(((Block) b).getLocation()))
            .collect(Collectors.toCollection(ArrayList::new));
      } else if (blockLocations.get(0) instanceof SimplifiedLocation) {
        // Perform actions specific to SimplifiedLocation
        this.blockLocations = (ArrayList<SimplifiedLocation>) blockLocations;
      } else {
        throw new IllegalArgumentException("Invalid blockLocations type");
      }

      Material material =
          XMaterial.matchXMaterial(getGeneratorObject().blockType().getType().toString())
              .orElseThrow(() -> new RuntimeException("Invalid item stack"))
              .parseItem()
              .getType();

      List<Map<?, ?>> generatorsConfig = GensPlus.getInstance()
          .getConfig().getMapList("generators");

      Map<?, ?> matchingGeneratorConfig = generatorsConfig.stream()
          .filter(generatorConfig -> generatorConfig.get("name")
              .equals(getGeneratorObject().name()))
          .findFirst()
          .orElse(null);

      if (matchingGeneratorConfig == null) {
        return;
      }

      List<String> lines = ((List<String>) matchingGeneratorConfig.get("hologramLines")).isEmpty()
          ? GensPlus.getInstance().getConfig()
          .getStringList(Config.DEFAULT_HOLOGRAM_LINES.getPath())
          : (List<String>) matchingGeneratorConfig.get("hologramLines");

      lines = lines
          .stream()
          .map(line -> line.replace("%name%", getGeneratorObject().name()))
          .map(line -> line.replace("%tier%",
              String.valueOf(getGeneratorObject().tier())))
          .map(line -> line.replace("%speed%",
              String.valueOf(getGeneratorObject().speed())))
          .map(line -> line.replace("%spawnItem%",
              getGeneratorObject().spawnItem().getType().toString()))
          .map(line -> line.replace("%sellPrice%",
              String.valueOf(getGeneratorObject().sellPrice())))
          .map(ChatUtil::translate)
          .toList();

      if (!Config.HOLOGRAMS_ENABLED.getBoolean()) {
        return;
      }

      try {
        Hologram hologram = HologramsUtil.createHologram(getCenter(), lines, material);
        if (hologram != null) {
          this.hologramId = hologram.getId().toString();
        }
      } catch (Exception e) {
        if (Config.DEVELOPER_OPTIONS.getBoolean()) {
          e.printStackTrace();
        }
      }
    }

    public GeneratorLocation(String playerId, Integer generator, List<?> blockLocations) {
      this(playerId, null, generator, blockLocations);
    }

    public void removeBlock(Block block) {
      blockLocations.remove(SimplifiedLocation.fromLocation(block.getLocation()));

      if (blockLocations.isEmpty()) {
        GensPlus.getInstance().getLocationsData().removeLocation(this);
      }
    }

    public void removeSimpleBlock(SimplifiedLocation location) {
      blockLocations.remove(location);

      if (blockLocations.isEmpty()) {
        GensPlus.getInstance().getLocationsData().removeLocation(this);
      }
    }

    public OfflinePlayer getPlacedBy() {
      return Bukkit.getOfflinePlayer(UUID.fromString(playerId));
    }

    public World getWorld() {
      return blockLocations.stream().findFirst().orElseThrow().getLocation().getWorld();
    }

    /**
     * Gets the center of the generator.
     *
     * @return The center of the generator.
     */
    public ArrayList<Block> getBlockLocations() {
      return blockLocations.stream()
          .map(SimplifiedLocation::getLocation)
          .map(location -> {
            if (location == null) {
              return null;
            }

            return location.getBlock();
          })
          .collect(Collectors.toCollection(ArrayList::new));
    }

    public ArrayList<SimplifiedLocation> getSimplifiedBlockLocations() {
      return blockLocations;
    }

    /**
     * Gets the generator object.
     *
     * @return Generator object.
     */
    public GeneratorsData.Generator getGeneratorObject() {

      return GensPlus.getInstance()
          .getGeneratorsData()
          .getGenerator(generator);
    }

    public GeneratorLocation getNextTier() {
      return new GeneratorLocation(playerId, generator + 1, blockLocations);
    }

    /**
     * Spawns the items for generators.
     */
    @SuppressWarnings("SuspiciousMethodCalls")
    public void spawn() {
      Location location = getCenter();

      OfflinePlayer player = getPlacedBy();

      if (Config.DISABLE_GENERATORS_WHEN_OFFLINE.getBoolean() && !player.isOnline()) {
        return;
      }

      if (Config.CHUNK_RADIUS_ENABLED.getBoolean() && !hasPlayer()) {
        return;
      }

      List<Item> items = new ArrayList<>();

      long multiplier = (EventLoop.getActiveEvent().event() instanceof DropEvent event
          ? event.getMultiplier() : 1);

      if (Config.HOLOGRAMS_ENABLED.getBoolean()) {
        // Drop items naturally at a single location
        for (int i = 0; i < multiplier * blockLocations.size(); i++) {
          Item item = location.getWorld().dropItemNaturally(
              location.clone().add(0.5, 1, 0.5),
              getGeneratorObject().spawnItem()
          );
          items.add(item);
        }
      } else {
        // Drop items at multiple locations with zero velocity
        blockLocations.forEach(loc -> IntStream.range(0, (int) multiplier)
            .mapToObj(i -> loc.getLocation().getWorld().dropItem(
                loc.getLocation().clone().add(0.5, 1, 0.5),
                getGeneratorObject().spawnItem()
            ))
            .forEach(item -> {
              item.setVelocity(new Vector(0, 0, 0));
              items.add(item);
            }));
      }


      final long ticks = TimeUtil.parseTime(
          GensPlus.getInstance().getConfig().getString(Config.ITEM_DESPAWN_TIME.getPath()));

      Bukkit.getScheduler()
          .runTaskLater(GensPlus.getInstance(), () -> getWorld().getEntities().stream()
              .filter(entity -> entity instanceof Item)
              .filter(items::contains)
              .forEach(Entity::remove), ticks);

    }

    /**
     * Gets the center of the generator.
     */
    public Location getCenter() {
      double minX = Integer.MAX_VALUE;
      double minZ = Integer.MAX_VALUE;
      double maxX = Integer.MIN_VALUE;
      double maxZ = Integer.MIN_VALUE;

      for (SimplifiedLocation location : blockLocations) {
        Location loc = location.getLocation();
        int x = loc.getBlockX();
        int z = loc.getBlockZ();

        minX = Math.min(minX, x);
        minZ = Math.min(minZ, z);
        maxX = Math.max(maxX, x);
        maxZ = Math.max(maxZ, z);
      }

      double centerX = (minX + maxX) / 2;
      double centerZ = (minZ + maxZ) / 2;

      // I need to block with the highest Y value
      double centerY = blockLocations.stream()
          .map(SimplifiedLocation::getLocation)
          .map(Location::getBlockY)
          .max(Integer::compareTo)
          .orElse(0);

      // Retrieve the block at the calculated center coordinates
      return new Location(getWorld(), centerX + 0.5, centerY + 1, centerZ + 0.5);
    }

    private boolean hasPlayer() {
      int r = PlayerUtil.getRadius(getPlacedBy().getPlayer());

      for (SimplifiedLocation simplifiedLocation : blockLocations) {
        Location location = simplifiedLocation.getLocation();

        // Check if there are any players in 10 block radius from the location
        int chunkRadius = (int) Math.ceil((double) r / 16); // Convert blocks to chunks (assuming each chunk is 16x16)
        for (Entity entity : location.getWorld().getNearbyEntities(location, chunkRadius * 16, 256, chunkRadius * 16)) { // Adjust the distance to chunks
          if (entity instanceof Player) {
            return true;
          }
        }
      }

      return false;
    }

    public Hologram getHologram() {
      return HologramsUtil.getHologram(hologramId);
    }

    public void setHologram(Hologram hologram) {
      if (hologram != null) {
        this.hologramId = hologram.getId().toString();
      }
    }

    @Override
    public String toString() {
      return "GeneratorLocation{" +
          "playerId='" + playerId + '\'' +
          ", islandId='" + islandId + '\'' +
          ", generator=" + generator +
          ", blockLocations=" + blockLocations +
          ", hologramId='" + hologramId + '\'' +
          '}';
    }
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\PlayerData.java
================================================================================

package xyz.arcadiadevs.gensplus.models;


import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.List;
import java.util.UUID;

/**
 * The PlayerData class represents the data associated with a player in GensPlus.
 */
public record PlayerData(List<Data> data) {

  /**
   * Gets the PlayerData object representing the player with the specified UUID.
   *
   * @param uuid The UUID of the player.
   * @return The PlayerData object representing the player.
   */
  public Data getData(UUID uuid) {
    return data.stream().filter(d -> d.uuid.equals(uuid)).findFirst().orElse(null);
  }

  /**
   * Creates a new PlayerData object with the specified properties.
   *
   * @param uuid  The UUID of the player.
   * @param limit The limit of the player.
   */
  public void create(UUID uuid, int limit) {
    Data data = new Data(uuid, limit);
    this.data.add(data);
  }

  /**
   * The Data class represents the data associated with a player in GensPlus.
   */
  @AllArgsConstructor
  @Getter
  public static class Data {

    private UUID uuid;

    @Setter
    private int limit;

    public static void addToLimit(Data data, int amount) {
      data.limit += amount;
    }

    public String toString() {
      return "Data(uuid=" + this.getUuid() + ", limit=" + this.getLimit() + ")";
    }
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\WandData.java
================================================================================

package xyz.arcadiadevs.gensplus.models;

import com.awaitquality.api.spigot.chat.formatter.Formattable;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.utils.config.Config;

/**
 * The WandData class represents the data associated with a wand in GensPlus.
 */

public record WandData(List<Wand> wands) {

  public Wand getWand(UUID uuid) {
    return wands.stream().filter(wand -> wand.getUuid().equals(uuid)).findFirst().orElse(null);
  }

  /**
   * Creates a new wand with the specified properties.
   *
   * @param type       The type of wand.
   * @param uses       The number of uses the wand has.
   * @param multiplier The multiplier of the wand.
   * @return The Wand object representing the wand.
   */
  public Wand create(Wand.WandType type, int uses, double multiplier) {
    Wand wandData = new Wand(UUID.randomUUID(), type, uses, multiplier, 0, 0);
    wands.add(wandData);
    return wandData;
  }

  public Wand remove(UUID uuid) {
    Wand wand = getWand(uuid);
    wands.remove(wand);
    return wand;
  }

  @AllArgsConstructor
  @Getter
  @Setter
  public static class Wand implements Formattable {
    private UUID uuid;
    private WandType type;
    private int uses;
    private double multiplier;
    private long totalEarned;
    private long totalItemsSold;

    /**
     * The WandType enum represents the type of wand in GensPlus.
     */
    public enum WandType {
      SELL_WAND,
    }

    @Override
    public HashMap<String, String> getPlaceHolders() {
      HashMap<String, String> output = new HashMap<>();
      output.put("%uses%", uses == -1 ? Config.SELL_WAND_UNLIMITED_USES_PREFIX.getString() : String.valueOf(uses));
      output.put("%multiplier%", String.valueOf(multiplier));
      output.put("%total_earned%", GensPlus.getInstance().getEcon().format(totalEarned));
      output.put("%total_items_sold%", String.valueOf(totalItemsSold));
      return output;
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\events\ActiveEvent.java
================================================================================

package xyz.arcadiadevs.gensplus.models.events;

/**
 * The ActiveEvent record represents an active event in GensPlus.
 * It stores information about the event, its start time, and end time.
 */
public record ActiveEvent(Event event, long startTime, long endTime) {
}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\events\DropEvent.java
================================================================================

package xyz.arcadiadevs.gensplus.models.events;

/**
 * The DropEvent class represents a drop event in GensPlus.
 * It extends the base Event class and provides specific functionality for drop events.
 */
public class DropEvent extends Event {

  /**
   * Constructs a new DropEvent with the specified multiplier and name.
   *
   * @param multiplier The multiplier value associated with the drop event.
   * @param name       The name of the drop event.
   */
  public DropEvent(long multiplier, String name) {
    super(multiplier, name);
  }
}




================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\events\Event.java
================================================================================

package xyz.arcadiadevs.gensplus.models.events;

import lombok.Getter;
import lombok.Setter;

/**
 * The Event class represents an event in GensPlus. It provides a base class for specific event
 * types.
 */
public abstract class Event {

  /**
   * The multiplier value associated with the event.
   */
  @Getter
  protected final long multiplier;

  /**
   * The name of the event.
   */
  @Getter
  @Setter
  protected String name;

  /**
   * Constructs a new Event with the specified multiplier and name.
   *
   * @param multiplier The multiplier value associated with the event.
   * @param name       The name of the event.
   */
  public Event(long multiplier, String name) {
    this.multiplier = multiplier;
    this.name = name;
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\events\SellEvent.java
================================================================================

package xyz.arcadiadevs.gensplus.models.events;

/**
 * The SellEvent class represents a sell event in GensPlus. It is a specific type of event
 * where players can sell items for a multiplier.
 */
public class SellEvent extends Event {

  /**
   * Constructs a new SellEvent with the specified multiplier and name.
   *
   * @param multiplier The multiplier value associated with the sell event.
   * @param name       The name of the sell event.
   */
  public SellEvent(long multiplier, String name) {
    super(multiplier, name);
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\events\SpeedEvent.java
================================================================================

package xyz.arcadiadevs.gensplus.models.events;

/**
 * The SpeedEvent class represents a speed event in GensPlus. It is a specific type of
 * event where players can enhance the speed of certain actions with a multiplier.
 */
public class SpeedEvent extends Event {

  /**
   * Constructs a new SpeedEvent with the specified multiplier and name.
   *
   * @param multiplier The multiplier value associated with the speed event.
   * @param name       The name of the speed event.
   */
  public SpeedEvent(long multiplier, String name) {
    super(multiplier, name);
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\models\location\SimplifiedLocation.java
================================================================================

package xyz.arcadiadevs.gensplus.models.location;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;

import java.util.UUID;

/**
 * A simplified representation of a Bukkit Location.
 * This record represents a location in a specific world with x, y, and z coordinates.
 */
public record SimplifiedLocation(UUID world, double x, double y, double z) {

  /**
   * Retrieves the Bukkit Location corresponding to this simplified location.
   *
   * @return The Bukkit Location, or null if the world is not loaded.
   */
  public Location getLocation() {
    World w = Bukkit.getWorld(world);

    if (w == null) {
      Bukkit.getLogger().severe("=============================================");
      Bukkit.getLogger().severe("This is not a bug or crash. Please read below");
      Bukkit.getLogger().severe("And make sure the world exists or remove block");
      Bukkit.getLogger().severe("data/block_data.yml to reset your gens data.");
      Bukkit.getLogger().severe("=============================================");
      Bukkit.getLogger().severe("World is null for generator location "
          + world + ", did you remove or rename your world? | Shutting down server...");
      Bukkit.shutdown();
      return null;
    }

    return new Location(w, x, y, z);
  }

  /**
   * Creates a simplified location from a Bukkit Location.
   *
   * @param location The Bukkit Location to create the simplified location from.
   * @return The simplified location.
   */
  public static SimplifiedLocation fromLocation(Location location) {
    return new SimplifiedLocation(location.getWorld().getUID(), location.getX(),
        location.getY(), location.getZ());
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\placeholders\PapiHandler.java
================================================================================

package xyz.arcadiadevs.gensplus.placeholders;

import lombok.AllArgsConstructor;
import me.clip.placeholderapi.expansion.PlaceholderExpansion;
import org.bukkit.OfflinePlayer;
import org.bukkit.plugin.Plugin;
import org.jetbrains.annotations.NotNull;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.tasks.EventLoop;
import xyz.arcadiadevs.gensplus.utils.PlayerUtil;
import xyz.arcadiadevs.gensplus.utils.TimeUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;

/**
 * The PlaceHolder class is a placeholder expansion for GensPlus. It provides placeholders that
 * can be used in other plugins or systems to retrieve dynamic information.
 */
@AllArgsConstructor
public class PapiHandler extends PlaceholderExpansion {

  private final Plugin plugin;
  private final LocationsData locationsData;
  private final PlayerData playerData;

  /**
   * Checks if the placeholder expansion can be registered.
   *
   * @return true if the expansion can be registered, false otherwise.
   */
  @Override
  public boolean canRegister() {
    return true;
  }

  /**
   * Retrieves the identifier for the placeholder expansion.
   *
   * @return The identifier for the expansion.
   */
  @Override
  public @NotNull String getIdentifier() {
    return "gensplus";
  }

  /**
   * Retrieves the name of the placeholder expansion.
   *
   * @return The name of the expansion.
   */
  @Override
  public @NotNull String getName() {
    return "GensPlus";
  }

  /**
   * Retrieves the author of the placeholder expansion.
   *
   * @return The author of the expansion.
   */
  @Override
  public @NotNull String getAuthor() {
    return plugin.getDescription().getAuthors().toString();
  }

  /**
   * Retrieves the version of the placeholder expansion.
   *
   * @return The version of the expansion.
   */
  @Override
  public @NotNull String getVersion() {
    return plugin.getDescription().getVersion();
  }

  /**
   * Processes the placeholder request and returns the corresponding value.
   *
   * @param player The player for whom the placeholder is being requested.
   * @param params The parameters specifying the placeholder.
   * @return The value of the requested placeholder.
   * @throws IllegalStateException if an unexpected parameter value is encountered.
   */
  @Override
  public String onRequest(OfflinePlayer player, String params) {
    final boolean useCommands = Config.LIMIT_PER_PLAYER_USE_COMMANDS.getBoolean();
    final boolean usePermissions = Config.LIMIT_PER_PLAYER_USE_PERMISSIONS.getBoolean();

    return switch (params) {
      case "event_timer" -> {
        final long time = EventLoop.getActiveEvent().endTime() - System.currentTimeMillis();
        yield TimeUtil.millisToTime(time);
      }

      case "event_name" ->
          EventLoop.getActiveEvent().event() == null ? "No Events" : EventLoop.getActiveEvent().event().getName();

      case "gen_limit" -> {
        if (!Config.LIMIT_PER_PLAYER_ENABLED.getBoolean()) {
          yield Config.LIMIT_PER_PLAYER_UNLIMITED_PLACEHOLDER.getString();
        }

        if (usePermissions) {
          yield PlayerUtil.getGeneratorLimitPerPlayer(player.getPlayer()).toString();
        }
        if (useCommands) {
          yield String.valueOf(playerData.getData(player.getUniqueId()).getLimit());
        }

        yield Config.LIMIT_PER_PLAYER_DEFAULT_LIMIT.getString();
      }

      case "gen_placed" -> locationsData.getGeneratorsCountByPlayer(player.getPlayer()).toString();
      case "sell_multiplier" -> PlayerUtil.getMultiplier(player.getPlayer()).toString();
      default -> throw new IllegalStateException("Unexpected value: " + params);
    };
  }

  @Override
  public boolean persist() {
    return true;
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\tasks\CleanupTask.java
================================================================================

package xyz.arcadiadevs.gensplus.tasks;

import lombok.AllArgsConstructor;
import org.bukkit.block.Block;
import org.bukkit.scheduler.BukkitRunnable;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.utils.SkyblockUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;

import java.util.ArrayList;

/**
 * This class represents a Bukkit task responsible for cleaning up generator locations.
 * It extends BukkitRunnable to allow for asynchronous execution.
 */
@AllArgsConstructor
public class CleanupTask extends BukkitRunnable {

  private final LocationsData locationsData;

  /**
   * Runs the cleanup operation, removing invalid block locations for each generator.
   * Also updates the generator's island ID based on the remaining block locations.
   */
  @Override
  public void run() {
    for (LocationsData.GeneratorLocation location : locationsData.locations()) {
      if (location.getBlockLocations().isEmpty()) {
        locationsData.removeLocation(location);
        continue;
      }

      GeneratorsData.Generator generator = location.getGeneratorObject();
      ArrayList<Block> blocks = location.getBlockLocations();

      for (Block block : location.getBlockLocations()) {
        if (block.getType() == generator.blockType().getType()) {
          continue;
        }

        if (Config.DEVELOPER_OPTIONS.getBoolean()) {
          GensPlus.getInstance().getLogger().info("[CLEANUPTASK] 1. Removing location: " + location);
        }

        blocks.remove(block);
        locationsData.removeLocation(location);
      }

      if (location.getWorld().isChunkLoaded(0, 0)) {
        continue;
      }

      location.getSimplifiedBlockLocations()
          .removeIf(simplifiedLocation -> simplifiedLocation.getLocation() == null
              || simplifiedLocation.getLocation().getBlock().getType()
              != generator.blockType().getType());

      if (location.getBlockLocations().isEmpty()) {
        if (Config.DEVELOPER_OPTIONS.getBoolean()) {
          GensPlus.getInstance().getLogger().info("[CLEANUPTASK] 2. Removing location: " + location);
        }

        locationsData.removeLocation(location);
      }
    }

    updateGens();
  }

  private void updateGens() {
    for (LocationsData.GeneratorLocation location : locationsData.locations()) {
      if (location.getBlockLocations().isEmpty()) {
        continue;
      }

      Block block = location.getBlockLocations().stream().findAny().orElse(null);

      if (block == null) {
        continue;
      }

      String id = SkyblockUtil.getIslandId(block.getLocation());

      if (id == null) {
        continue;
      }

      location.setIslandId(id);
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\tasks\DataSaveTask.java
================================================================================

package xyz.arcadiadevs.gensplus.tasks;

import java.io.FileWriter;
import java.io.IOException;
import org.bukkit.scheduler.BukkitRunnable;
import xyz.arcadiadevs.gensplus.GensPlus;

/**
 * The DataSaveTask class is a BukkitRunnable task responsible for saving block data to JSON. It
 * periodically saves the generator data to a JSON file.
 */
public class DataSaveTask extends BukkitRunnable {

  private final GensPlus instance;

  /**
   * Constructs a new DataSaveTask with the given GensPlus instance.
   *
   * @param instance The GensPlus instance.
   */
  public DataSaveTask(GensPlus instance) {
    this.instance = instance;
  }

  /**
   * Executes the data saving task. It calls the method to save block data to JSON.
   */
  @Override
  public void run() {
    saveBlockDataToJson();
    saveWandDataToJson();
    savePlayerDataToJson();
  }

  /**
   * Saves the block data to a JSON file. It converts the generator data to JSON format and writes
   * it to a file.
   */
  public void saveBlockDataToJson() {
    try (FileWriter writer = new FileWriter(instance.getDataFolder() + "/data/block_data.json")) {
      instance.getGson().toJson(instance.getLocationsData().locations(), writer);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void saveWandDataToJson() {
    try (FileWriter writer = new FileWriter(instance.getDataFolder() + "/data/wands_data.json")) {
      instance.getGson().toJson(instance.getWandData().wands(), writer);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void savePlayerDataToJson() {
    try (FileWriter writer = new FileWriter(instance.getDataFolder() + "/data/player_data.json")) {
      instance.getGson().toJson(instance.getPlayerData().data(), writer);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\tasks\EventLoop.java
================================================================================

package xyz.arcadiadevs.gensplus.tasks;

import lombok.Getter;
import org.bukkit.scheduler.BukkitRunnable;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.events.ActiveEvent;
import xyz.arcadiadevs.gensplus.models.events.Event;
import xyz.arcadiadevs.gensplus.utils.TimeUtil;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

import java.util.List;
import java.util.Random;

/**
 * The EventLoop class is a BukkitRunnable task responsible for managing events in a loop. It
 * randomly selects and activates events, and transitions between events based on the specified
 * durations.
 */
public class EventLoop extends BukkitRunnable {

  @Getter
  private static ActiveEvent activeEvent = null;
  private static ActiveEvent nextEvent = null;
  private static List<Event> events;
  private static long timeBetweenEvents;
  private static long eventDuration;

  /**
   * Constructs a new EventLoop with the given plugin and list of events.
   *
   * @param events The list of events to cycle through.
   */
  public EventLoop(List<Event> events) {
    EventLoop.events = events;
    timeBetweenEvents = TimeUtil.parseTimeMillis(Config.EVENTS_TIME_BETWEEN_EVENTS
        .getString());
    eventDuration = TimeUtil.parseTimeMillis(Config.EVENTS_EVENT_DURATION.getString());

    activeEvent = new ActiveEvent(null, System.currentTimeMillis(),
        System.currentTimeMillis() + timeBetweenEvents);

    setRandomNextEvent();
  }

  private static void setRandomNextEvent() {
    Random random = new Random();
    if (events.isEmpty()) {
      nextEvent = null;
      return;
    }
    int randomNumber = random.nextInt(events.size());
    nextEvent = new ActiveEvent(
        events.get(randomNumber),
        System.currentTimeMillis() + timeBetweenEvents,
        System.currentTimeMillis() + timeBetweenEvents + eventDuration
    );
  }

  /**
   * Executes the event loop task. It randomly selects an event, activates it, and transitions to
   * the next event based on the specified durations.
   */
  @Override
  public void run() {
    if (nextEvent != null && nextEvent.startTime() < System.currentTimeMillis()) {
      activeEvent = nextEvent;
      Messages.EVENT_STARTED.format(
              "event", activeEvent.event().getName(),
              "time", TimeUtil.millisToTime(eventDuration))
          .send(GensPlus.getInstance().getConfig()
              .getBoolean(Config.EVENTS_BROADCAST_ENABLED.getPath()));
      nextEvent = null;
      return;
    }

    if (activeEvent.endTime() < System.currentTimeMillis()) {
      Messages.EVENT_ENDED.format(
              "event", activeEvent.event().getName(),
              "time", TimeUtil.millisToTime(timeBetweenEvents))
          .send(GensPlus.getInstance().getConfig()
              .getBoolean(Config.EVENTS_BROADCAST_ENABLED.getPath()));

      activeEvent = new ActiveEvent(null, System.currentTimeMillis(),
          System.currentTimeMillis() + timeBetweenEvents);

      setRandomNextEvent();
    }
  }

  /**
   * Sets the next event to the given event.
   *
   * @param event The event to set as the next event.
   */
  public static void setNextEvent(Event event) {
    if (event == null) {
      return;
    }

    activeEvent = new ActiveEvent(
        event,
        System.currentTimeMillis(),
        System.currentTimeMillis() + eventDuration
    );

    nextEvent = activeEvent;

  }

  /**
   * Stops the current event.
   */
  public static void stopEvent() {
    activeEvent = new ActiveEvent(null, System.currentTimeMillis(),
        System.currentTimeMillis() + timeBetweenEvents);

    Messages.EVENT_FORCE_ENDED.format("time", TimeUtil.millisToTime(timeBetweenEvents))
        .send(Config.EVENTS_BROADCAST_ENABLED.getBoolean());

    nextEvent = null;

    setRandomNextEvent();
  }

}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\tasks\SpawnerTask.java
================================================================================

package xyz.arcadiadevs.gensplus.tasks;

import java.util.HashMap;
import java.util.List;
import org.bukkit.Bukkit;
import org.bukkit.scheduler.BukkitRunnable;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.LocationsData;
import xyz.arcadiadevs.gensplus.models.events.ActiveEvent;
import xyz.arcadiadevs.gensplus.models.events.SpeedEvent;

/**
 * The SpawnerTask class is a BukkitRunnable task responsible for spawning items from generators at
 * regular intervals. It tracks the next spawn time for each generator and spawns items based on
 * their speed.
 */
public class SpawnerTask extends BukkitRunnable {

  private final List<LocationsData.GeneratorLocation> blockData;
  private final GeneratorsData generatorsData;
  private HashMap<GeneratorsData.Generator, Long> genNextSpawn;

  /**
   * Constructs a new SpawnerTask with the given block data and generator data.
   *
   * @param blockData      The list of generator locations.
   * @param generatorsData The generator data.
   */
  public SpawnerTask(List<LocationsData.GeneratorLocation> blockData,
      GeneratorsData generatorsData) {
    this.blockData = blockData;
    this.generatorsData = generatorsData;
    initialize();
  }

  /**
   * Initializes the spawner task by setting up the next spawn time for each generator.
   */
  private void initialize() {
    genNextSpawn = new HashMap<>();
    for (GeneratorsData.Generator generator : generatorsData.generators()) {
      genNextSpawn.put(generator, System.currentTimeMillis() + generator.speed());
    }
  }

  /**
   * Executes the spawner task. It checks if it is time to spawn items for each generator and spawns
   * items accordingly.
   */
  @Override
  public void run() {
    for (GeneratorsData.Generator generator : generatorsData.generators()) {
      if (genNextSpawn.get(generator) > System.currentTimeMillis()) {
        continue;
      }

      List<LocationsData.GeneratorLocation> blocksToSpawn = blockData.stream()
          .filter(block -> block.getGenerator() == generator.tier())
          .toList();

      Bukkit.getScheduler().runTask(GensPlus.getInstance(), () -> {
        for (LocationsData.GeneratorLocation block : blocksToSpawn) {
          block.spawn();
        }
      });

      ActiveEvent activeEvent = EventLoop.getActiveEvent();

      long multiplier = (long) (activeEvent.event() instanceof SpeedEvent
          ? EventLoop.getActiveEvent().event().getMultiplier()
          : 1.0);
      genNextSpawn.put(generator,
          System.currentTimeMillis() + generator.speed() / multiplier * 1000L);
    }
  }

}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\ActionBarUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import com.awaitquality.api.spigot.chat.ChatUtil;
import com.cryptomorin.xseries.messages.ActionBar;
import org.bukkit.entity.Player;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ActionBarUtil {
  private static boolean works = true;

  private static final String version = ServerVersion.getServerVersionString();

  private static final boolean useOldMethods =
      version.equalsIgnoreCase("v1_8_R1") || version.startsWith("1_7_");

  public static void sendActionBar(Player player, String message) {
    if (!player.isOnline()) {
      return;
    }

    ActionBar.sendActionBar(player, ChatUtil.translate(message));
  }

  private static void sendActionBarPost112(Player player, String message) {
    if (!player.isOnline()) {
      return;
    }

    try {
      Class<?> craftPlayerClass =
          Class.forName("org.bukkit.craftbukkit." + version + ".entity.CraftPlayer");
      Object craftPlayer = craftPlayerClass.cast(player);
      Class<?> c4 = Class.forName("net.minecraft.server." + version + ".PacketPlayOutChat");
      Class<?> c5 = Class.forName("net.minecraft.server." + version + ".Packet");
      Class<?> c2 = Class.forName("net.minecraft.server." + version + ".ChatComponentText");
      Class<?> c3 = Class.forName("net.minecraft.server." + version + ".IChatBaseComponent");
      Class<?> chatMessageTypeClass =
          Class.forName("net.minecraft.server." + version + ".ChatMessageType");
      Object[] chatMessageTypes = chatMessageTypeClass.getEnumConstants();
      Object chatMessageType = null;
      byte b;
      int i;
      Object[] arrayOfObject1;
      for (i = (arrayOfObject1 = chatMessageTypes).length, b = 0; b < i; ) {
        Object obj = arrayOfObject1[b];
        if (obj.toString().equals("GAME_INFO")) {
          chatMessageType = obj;
        }
        b++;
      }
      Object o = c2.getConstructor(new Class[] {String.class}).newInstance(message);
      Object ppoc = c4.getConstructor(new Class[] {c3, chatMessageTypeClass}).newInstance(o,
          chatMessageType);
      Method m1 = craftPlayerClass.getDeclaredMethod("getHandle");
      Object h = m1.invoke(craftPlayer);
      Field f1 = h.getClass().getDeclaredField("playerConnection");
      Object pc = f1.get(h);
      Method m5 = pc.getClass().getDeclaredMethod("sendPacket", c5);
      m5.invoke(pc, ppoc);
    } catch (Exception ex) {
      ex.printStackTrace();
      works = false;
    }
  }

  private static void sendActionBarPre112(Player player, String message) {
    if (!player.isOnline()) {
      return;
    }

    try {
      Object ppoc;
      Class<?> craftPlayerClass =
          Class.forName("org.bukkit.craftbukkit." + version + ".entity.CraftPlayer");
      Object craftPlayer = craftPlayerClass.cast(player);
      Class<?> c4 = Class.forName("net.minecraft.server." + version + ".PacketPlayOutChat");
      Class<?> c5 = Class.forName("net.minecraft.server." + version + ".Packet");
      if (useOldMethods) {
        Class<?> c2 = Class.forName("net.minecraft.server." + version + ".ChatSerializer");
        Class<?> c3 = Class.forName("net.minecraft.server." + version + ".IChatBaseComponent");
        Method m3 = c2.getDeclaredMethod("a", String.class);
        Object cbc = c3.cast(m3.invoke(c2, "{\"text\": \"" + message + "\"}"));
        ppoc = c4.getConstructor(new Class[] {c3, byte.class}).newInstance(cbc,
            (byte) 2);
      } else {
        Class<?> c2 = Class.forName("net.minecraft.server." + version + ".ChatComponentText");
        Class<?> c3 = Class.forName("net.minecraft.server." + version + ".IChatBaseComponent");
        Object o = c2.getConstructor(new Class[] {String.class}).newInstance(message);
        ppoc = c4.getConstructor(new Class[] {c3, byte.class}).newInstance(o,
            (byte) 2);
      }
      Method m1 = craftPlayerClass.getDeclaredMethod("getHandle");
      Object h = m1.invoke(craftPlayer);
      Field f1 = h.getClass().getDeclaredField("playerConnection");
      Object pc = f1.get(h);
      Method m5 = pc.getClass().getDeclaredMethod("sendPacket", c5);
      m5.invoke(pc, ppoc);
    } catch (Exception ex) {
      ex.printStackTrace();
      works = false;
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\GuiUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import com.cryptomorin.xseries.XMaterial;
import java.util.List;
import java.util.Random;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.guilib.Gui;
import xyz.arcadiadevs.guilib.GuiItem;
import xyz.arcadiadevs.guilib.GuiItemType;
import xyz.arcadiadevs.guilib.ItemBuilder;

/**
 * The GuiUtil class provides utility methods for GUI-related operations.
 */
public class GuiUtil {

  /**
   * Adds a border to the specified SGMenu with the given number of rows.
   *
   * @param menu The SGMenu to add the border to.
   */
  public static void addBorder(Gui menu, String material) {
    ItemBuilder itemBuilder = new ItemBuilder(XMaterial.matchXMaterial(material)
        .orElse(XMaterial.WHITE_STAINED_GLASS_PANE)
        .parseItem());

    if (!material.equals("AIR")) {
      itemBuilder.name(GensPlus.getInstance().getConfig()
          .getString(Config.GUIS_GENERATORS_GUI_BORDER_NAME.getPath()));
    }

    for (int i = 0; i < 9; i++) {
      menu.setItem(
          i,
          new GuiItem(
              GuiItemType.BORDER,
              itemBuilder.build(),
              null
          )
      );
    }

    for (int i = 0; i < menu.getRows(); i++) {
      menu.setItem(
          i * 9,
          new GuiItem(
              GuiItemType.BORDER,
              XMaterial.matchXMaterial(material)
                  .orElse(XMaterial.WHITE_STAINED_GLASS_PANE)
                  .parseItem(),
              null
          )
      );
    }

    for (int i = 0; i < menu.getRows(); i++) {
      menu.setItem(
          (i * 9) + 8,
          new GuiItem(
              GuiItemType.BORDER,
              XMaterial.matchXMaterial(material)
                  .orElse(XMaterial.WHITE_STAINED_GLASS_PANE)
                  .parseItem(),
              null
          )
      );
    }

    for (int i = (menu.getRows() - 1) * 9; i < ((menu.getRows() - 1) * 9) + 9; i++) {
      menu.setItem(
          i,
          new GuiItem(
              GuiItemType.BORDER,
              XMaterial.matchXMaterial(material)
                  .orElse(XMaterial.WHITE_STAINED_GLASS_PANE)
                  .parseItem(),
              null
          )
      );
    }
  }

  /**
   * Fills the specified SGMenu with the given material.
   *
   * @param menu     The SGMenu to fill.
   * @param materials The material to fill the SGMenu with.
   */
  @SafeVarargs
  public static void fillWithRandom(Gui menu, List<String>... materials) {
    Random random = new Random();
    int rows = menu.getRows();

    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < 9; j++) {
        menu.setItem(
            i * 9 + j,
            getRandomItem(materials[random.nextInt(materials.length)])
        );
      }
    }
  }

  private static GuiItem getRandomItem(List<String> materials) {
    Random random = new Random();
    String randomMaterial = materials.get(random.nextInt(materials.size()));

    ItemStack itemstack = new ItemBuilder(XMaterial.matchXMaterial(randomMaterial)
        .orElseThrow()
        .parseItem())
        .name(" ")
        .build();
    // Replace this with your logic to parse the material string into an actual item.
    // Here, we're assuming the material string is a valid material name.
    return new GuiItem(GuiItemType.BORDER, itemstack, null);
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\HologramsUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;
import org.holoeasy.hologram.Hologram;
import org.jetbrains.annotations.NotNull;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.utils.config.Config;

import java.util.List;
import java.util.UUID;

import static org.holoeasy.builder.HologramBuilder.*;

/**
 * The HologramsUtil class is responsible for handling hologram-related tasks in GensPlus.
 */
public class HologramsUtil {

  /**
   * Creates a hologram at the specified location with the specified text.
   *
   * @param location The location of the hologram.
   * @param text     The text of the hologram.
   * @param material The material of the hologram.
   * @return The hologram created.
   */
  public static Hologram createHologram(Location location, List<String> text, Material material) {
    if (!Config.HOLOGRAMS_ENABLED.getBoolean()) {
      return null;
    }

    try {
      Hologram[] result = new Hologram[1];
      Location holoLocation = location.clone().subtract(0, 1, 0);
      GensPlus.getInstance().getHologramPool().registerHolograms(() -> {
        result[0] = hologram(holoLocation, () -> {
          for (String line : text) {
            textline(line);
          }
          if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_13)) {
            item(new ItemStack(material));
          }
        });
      });
      return result[0];
    } catch (Exception e) {
      if (Config.DEVELOPER_OPTIONS.getBoolean()) {
        e.printStackTrace();
      }
      return null;
    }
  }

  public static Hologram getHologram(String id) {
    if (id == null) {
      return null;
    }

    return GensPlus.getInstance().getHologramPool().get(UUID.fromString(id));
  }

  public static void removeHologram(@NotNull Hologram hologram) {
    try {
      GensPlus.getInstance().getHologramPool().remove(hologram.getId());
    } catch (Exception e) {
      if (Config.DEVELOPER_OPTIONS.getBoolean()) {
        e.printStackTrace();
      }
    }
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\ItemUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import com.awaitquality.api.spigot.chat.formatter.Formatter;
import com.cryptomorin.xseries.XMaterial;
import dev.lone.itemsadder.api.CustomStack;
import io.github.bananapuncher714.nbteditor.NBTEditor;
import io.th0rgal.oraxen.api.OraxenItems;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.SkullMeta;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.WandData;
import xyz.arcadiadevs.guilib.ItemBuilder;

import java.util.List;

/**
 * The ItemUtils class provides utility methods for handling item-related operations.
 */
public class ItemUtil {

  /**
   * Returns an ItemStack representing a universal multi-version supported item,
   * or Oraxen's custom item.
   *
   * @return The universal item.
   */
  public static ItemStack getUniversalItem(String itemName, boolean enableItemsAdder, boolean enableHeads) {
    // Format: oraxen:ITEM_NAME
    if (itemName.toLowerCase().startsWith("oraxen:")) {
      itemName = itemName.substring(7);
      return OraxenItems.getItemById(itemName).build();
    }

    // Format: itemsadder:ITEM_NAME
    if (enableItemsAdder && itemName.toLowerCase().startsWith("itemsadder:")) {
      itemName = itemName.substring(11);

      CustomStack customStack = CustomStack.getInstance(itemName);

      if (customStack == null) {
        return null;
      }

      return customStack.getItemStack();
    }

    // Format: customId:123;ITEM_NAME
    if (itemName.toLowerCase().startsWith("customid:")) {
      itemName = itemName.substring(9);

      String[] idNameSplit = itemName.split(";");

      String id = idNameSplit[0];
      String name = idNameSplit[1];

      ItemStack item = XMaterial.matchXMaterial(name).orElseThrow().parseItem();
      ItemMeta meta = item.getItemMeta();

      // TODO fix 1.8
      if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_16)) {
        meta.setCustomModelData(Integer.parseInt(id));
      }

      item.setItemMeta(meta);

      return item;
    }

    ItemStack skull = new ItemStack(Material.PLAYER_HEAD);

    if (enableHeads && itemName.startsWith("head:")) {
      SkullMeta meta = (SkullMeta) skull.getItemMeta();
      meta.setOwningPlayer(Bukkit.getOfflinePlayer(itemName.substring(5)));
      skull.setItemMeta(meta);
      return skull;
    }

    XMaterial material = XMaterial.matchXMaterial(itemName).orElse(null);

    if (material == null) {
      return null;
    }

    return material.parseItem();
  }

  /**
   * Upgrades all generators in the inventory to the new
   * item format that uses NBT tags.
   *
   * @param inventory The inventory to upgrade.
   */
  public static void upgradeGens(Inventory inventory) {
    for (int i = 0; i < inventory.getSize(); i++) {
      ItemStack item = inventory.getItem(i);

      if (item == null) {
        continue;
      }

      ItemMeta meta = item.getItemMeta();

      if (meta == null) {
        continue;
      }

      if (!meta.hasLore()) {
        continue;
      }

      List<String> lore = meta.getLore();

      if (lore == null) {
        continue;
      }

      String firstLine = lore.get(0);

      if (firstLine.contains("Generator drop tier")) {
        final int tier = Integer.parseInt(firstLine.split(" ")[3]);

        lore.remove(0);
        meta.setLore(lore);
        item.setItemMeta(meta);

        item = NBTEditor.set(item, tier, "gensplus", "spawnitem", "tier");

        inventory.setItem(i, item);

        continue;
      }

      if (firstLine.contains("Generator tier")) {
        final int tier = Integer.parseInt(firstLine.split(" ")[2]);

        lore.remove(0);
        meta.setLore(lore);
        item.setItemMeta(meta);

        item = NBTEditor.set(item, tier, "gensplus", "blocktype", "tier");

        inventory.setItem(i, item);
      }
    }
  }

  /**
   * Returns a sell wand with the specified uses and multiplier.
   *
   * @param uses       The uses of the wand.
   * @param multiplier The multiplier of the wand.
   * @return The sell wand.
   */
  public static ItemStack getWand(WandData.Wand.WandType type, int uses, double multiplier) {
    WandData wandData = GensPlus.getInstance().getWandData();
    WandData.Wand wand = wandData.create(type, uses, multiplier);

    String configPrefix = "wands.sell-wand";

    FileConfiguration config = GensPlus.getInstance().getConfig();

    List<String> lore = config.getStringList(configPrefix + ".lore");

    List<String> formattedLore = Formatter.format(wand, lore);

    final Material material = XMaterial.matchXMaterial(config.getString(configPrefix + ".material"))
        .orElseThrow()
        .parseMaterial();


    final String formattedName = Formatter.format(wand, config.getString(configPrefix + ".name"));

    ItemBuilder itemBuilder = new ItemBuilder(material)
        .name(formattedName)
        .lore(formattedLore);

    ItemStack item = itemBuilder.build();

    String uuid = "sell-wand-uuid";

    item = NBTEditor.set(item, wand.getUuid().toString(), NBTEditor.CUSTOM_DATA, uuid);

    return item;
  }

  /**
   * Returns a sell wand with the specified uses and multiplier.
   *
   * @param uses       The uses of the wand.
   * @param multiplier The multiplier of the wand.
   * @return The sell wand.
   */
  public static ItemStack getSellWand(int uses, double multiplier) {
    return getWand(WandData.Wand.WandType.SELL_WAND, uses, multiplier);
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\LimitUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import org.bukkit.OfflinePlayer;
import xyz.arcadiadevs.gensplus.models.PlayerData;
import xyz.arcadiadevs.gensplus.utils.config.Config;

public class LimitUtil {

  public static int calculateCombinedLimit(OfflinePlayer player, PlayerData playerData) {
    int limitPerPlayer = 0;
    final boolean useCommands = Config.LIMIT_PER_PLAYER_USE_COMMANDS.getBoolean();
    final boolean usePermissions = Config.LIMIT_PER_PLAYER_USE_PERMISSIONS.getBoolean();

    if (usePermissions) {
      limitPerPlayer = PlayerUtil.getGeneratorLimitPerPlayer(player.getPlayer());
    }

    if (useCommands) {
      int commandLimit = playerData.getData(player.getUniqueId()).getLimit();

      if (usePermissions) {
        limitPerPlayer += commandLimit;
      } else {
        limitPerPlayer = commandLimit;
      }
    }

    return limitPerPlayer;
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\Metrics.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

/*
 * This Metrics class was auto-generated and can be copied into your project if you are
 * not using a build tool like Gradle or Maven for dependency management.
 *
 * IMPORTANT: You are not allowed to modify this class, except changing the package.
 *
 * Disallowed modifications include but are not limited to:
 *  - Remove the option for users to opt-out
 *  - Change the frequency for data submission
 *  - Obfuscate the code (every obfuscator should allow you to make an exception for specific files)
 *  - Reformat the code (if you use a linter, add an exception)
 *
 * Violations will result in a ban of your plugin and account from bStats.
 */

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.Callable;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.logging.Level;
import java.util.stream.Collectors;
import java.util.zip.GZIPOutputStream;
import javax.net.ssl.HttpsURLConnection;
import org.bukkit.Bukkit;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.java.JavaPlugin;

/**
 * bStats collects some data for plugin authors.
 *
 * <p>Check out <a href="https://bStats.org/">...</a> to learn more about bStats!
 */
public class Metrics {

  private final Plugin plugin;

  private final MetricsBase metricsBase;

  /**
   * Creates a new Metrics instance.
   *
   * @param plugin Your plugin instance.
   * @param serviceId The id of the service. It can be found at <a
   *     href="https://bstats.org/what-is-my-plugin-id">What is my plugin id?</a>
   */
  public Metrics(JavaPlugin plugin, int serviceId) {
    this.plugin = plugin;
    // Get the config file
    File bStatsFolder = new File(plugin.getDataFolder().getParentFile(), "bStats");
    File configFile = new File(bStatsFolder, "config.yml");
    YamlConfiguration config = YamlConfiguration.loadConfiguration(configFile);
    if (!config.isSet("serverUuid")) {
      config.addDefault("enabled", true);
      config.addDefault("serverUuid", UUID.randomUUID().toString());
      config.addDefault("logFailedRequests", false);
      config.addDefault("logSentData", false);
      config.addDefault("logResponseStatusText", false);
      // Inform the server owners about bStats
      config
          .options()
          .header(
              "bStats (https://bStats.org) collects some basic information for plugin authors, like how\n"
                  + "many people use their plugin and their total player count. It's recommended to keep bStats\n"
                  + "enabled, but if you're not comfortable with this, you can turn this setting off. There is no\n"
                  + "performance penalty associated with having metrics enabled, and data sent to bStats is fully\n"
                  + "anonymous.")
          .copyDefaults(true);
      try {
        config.save(configFile);
      } catch (IOException ignored) {
      }
    }
    // Load the data
    boolean enabled = config.getBoolean("enabled", true);
    String serverUUID = config.getString("serverUuid");
    boolean logErrors = config.getBoolean("logFailedRequests", false);
    boolean logSentData = config.getBoolean("logSentData", false);
    boolean logResponseStatusText = config.getBoolean("logResponseStatusText", false);
    metricsBase =
        new MetricsBase(
            "bukkit",
            serverUUID,
            serviceId,
            enabled,
            this::appendPlatformData,
            this::appendServiceData,
            submitDataTask -> Bukkit.getScheduler().runTask(plugin, submitDataTask),
            plugin::isEnabled,
            (message, error) -> this.plugin.getLogger().log(Level.WARNING, message, error),
            (message) -> this.plugin.getLogger().log(Level.INFO, message),
            logErrors,
            logSentData,
            logResponseStatusText);
  }

  /** Shuts down the underlying scheduler service. */
  public void shutdown() {
    metricsBase.shutdown();
  }

  /**
   * Adds a custom chart.
   *
   * @param chart The chart to add.
   */
  public void addCustomChart(CustomChart chart) {
    metricsBase.addCustomChart(chart);
  }

  private void appendPlatformData(JsonObjectBuilder builder) {
    builder.appendField("playerAmount", getPlayerAmount());
    builder.appendField("onlineMode", Bukkit.getOnlineMode() ? 1 : 0);
    builder.appendField("bukkitVersion", Bukkit.getVersion());
    builder.appendField("bukkitName", Bukkit.getName());
    builder.appendField("javaVersion", System.getProperty("java.version"));
    builder.appendField("osName", System.getProperty("os.name"));
    builder.appendField("osArch", System.getProperty("os.arch"));
    builder.appendField("osVersion", System.getProperty("os.version"));
    builder.appendField("coreCount", Runtime.getRuntime().availableProcessors());
  }

  private void appendServiceData(JsonObjectBuilder builder) {
    builder.appendField("pluginVersion", plugin.getDescription().getVersion());
  }

  private int getPlayerAmount() {
    try {
      // Around MC 1.8 the return type was changed from an array to a collection,
      // This fixes java.lang.NoSuchMethodError:
      // org.bukkit.Bukkit.getOnlinePlayers()Ljava/util/Collection;
      Method onlinePlayersMethod = Class.forName("org.bukkit.Server").getMethod("getOnlinePlayers");
      return onlinePlayersMethod.getReturnType().equals(Collection.class)
          ? ((Collection<?>) onlinePlayersMethod.invoke(Bukkit.getServer())).size()
          : ((Player[]) onlinePlayersMethod.invoke(Bukkit.getServer())).length;
    } catch (Exception e) {
      // Just use the new method if the reflection failed
      return Bukkit.getOnlinePlayers().size();
    }
  }

  public static class MetricsBase {

    /** The version of the Metrics class. */
    public static final String METRICS_VERSION = "3.0.2";

    private static final String REPORT_URL = "https://bStats.org/api/v2/data/%s";

    private final ScheduledExecutorService scheduler;

    private final String platform;

    private final String serverUuid;

    private final int serviceId;

    private final Consumer<JsonObjectBuilder> appendPlatformDataConsumer;

    private final Consumer<JsonObjectBuilder> appendServiceDataConsumer;

    private final Consumer<Runnable> submitTaskConsumer;

    private final Supplier<Boolean> checkServiceEnabledSupplier;

    private final BiConsumer<String, Throwable> errorLogger;

    private final Consumer<String> infoLogger;

    private final boolean logErrors;

    private final boolean logSentData;

    private final boolean logResponseStatusText;

    private final Set<CustomChart> customCharts = new HashSet<>();

    private final boolean enabled;

    /**
     * Creates a new MetricsBase class instance.
     *
     * @param platform The platform of the service.
     * @param serviceId The id of the service.
     * @param serverUuid The server uuid.
     * @param enabled Whether or not data sending is enabled.
     * @param appendPlatformDataConsumer A consumer that receives a {@code JsonObjectBuilder} and
     *     appends all platform-specific data.
     * @param appendServiceDataConsumer A consumer that receives a {@code JsonObjectBuilder} and
     *     appends all service-specific data.
     * @param submitTaskConsumer A consumer that takes a runnable with the submit task. This can be
     *     used to delegate the data collection to a another thread to prevent errors caused by
     *     concurrency. Can be {@code null}.
     * @param checkServiceEnabledSupplier A supplier to check if the service is still enabled.
     * @param errorLogger A consumer that accepts log message and an error.
     * @param infoLogger A consumer that accepts info log messages.
     * @param logErrors Whether or not errors should be logged.
     * @param logSentData Whether or not the sent data should be logged.
     * @param logResponseStatusText Whether or not the response status text should be logged.
     */
    public MetricsBase(
        String platform,
        String serverUuid,
        int serviceId,
        boolean enabled,
        Consumer<JsonObjectBuilder> appendPlatformDataConsumer,
        Consumer<JsonObjectBuilder> appendServiceDataConsumer,
        Consumer<Runnable> submitTaskConsumer,
        Supplier<Boolean> checkServiceEnabledSupplier,
        BiConsumer<String, Throwable> errorLogger,
        Consumer<String> infoLogger,
        boolean logErrors,
        boolean logSentData,
        boolean logResponseStatusText) {
      ScheduledThreadPoolExecutor scheduler =
          new ScheduledThreadPoolExecutor(1, task -> new Thread(task, "bStats-Metrics"));
      // We want delayed tasks (non-periodic) that will execute in the future to be
      // cancelled when the scheduler is shutdown.
      // Otherwise, we risk preventing the server from shutting down even when
      // MetricsBase#shutdown() is called
      scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
      this.scheduler = scheduler;
      this.platform = platform;
      this.serverUuid = serverUuid;
      this.serviceId = serviceId;
      this.enabled = enabled;
      this.appendPlatformDataConsumer = appendPlatformDataConsumer;
      this.appendServiceDataConsumer = appendServiceDataConsumer;
      this.submitTaskConsumer = submitTaskConsumer;
      this.checkServiceEnabledSupplier = checkServiceEnabledSupplier;
      this.errorLogger = errorLogger;
      this.infoLogger = infoLogger;
      this.logErrors = logErrors;
      this.logSentData = logSentData;
      this.logResponseStatusText = logResponseStatusText;
      checkRelocation();
      if (enabled) {
        // WARNING: Removing the option to opt-out will get your plugin banned from
        // bStats
        startSubmitting();
      }
    }

    public void addCustomChart(CustomChart chart) {
      this.customCharts.add(chart);
    }

    public void shutdown() {
      scheduler.shutdown();
    }

    private void startSubmitting() {
      final Runnable submitTask =
          () -> {
            if (!enabled || !checkServiceEnabledSupplier.get()) {
              // Submitting data or service is disabled
              scheduler.shutdown();
              return;
            }
            if (submitTaskConsumer != null) {
              submitTaskConsumer.accept(this::submitData);
            } else {
              this.submitData();
            }
          };
      // Many servers tend to restart at a fixed time at xx:00 which causes an uneven
      // distribution of requests on the
      // bStats backend. To circumvent this problem, we introduce some randomness into
      // the initial and second delay.
      // WARNING: You must not modify and part of this Metrics class, including the
      // submit delay or frequency!
      // WARNING: Modifying this code will get your plugin banned on bStats. Just
      // don't do it!
      long initialDelay = (long) (1000 * 60 * (3 + Math.random() * 3));
      long secondDelay = (long) (1000 * 60 * (Math.random() * 30));
      scheduler.schedule(submitTask, initialDelay, TimeUnit.MILLISECONDS);
      scheduler.scheduleAtFixedRate(
          submitTask, initialDelay + secondDelay, 1000 * 60 * 30, TimeUnit.MILLISECONDS);
    }

    private void submitData() {
      final JsonObjectBuilder baseJsonBuilder = new JsonObjectBuilder();
      appendPlatformDataConsumer.accept(baseJsonBuilder);
      final JsonObjectBuilder serviceJsonBuilder = new JsonObjectBuilder();
      appendServiceDataConsumer.accept(serviceJsonBuilder);
      JsonObjectBuilder.JsonObject[] chartData =
          customCharts.stream()
              .map(customChart -> customChart.getRequestJsonObject(errorLogger, logErrors))
              .filter(Objects::nonNull)
              .toArray(JsonObjectBuilder.JsonObject[]::new);
      serviceJsonBuilder.appendField("id", serviceId);
      serviceJsonBuilder.appendField("customCharts", chartData);
      baseJsonBuilder.appendField("service", serviceJsonBuilder.build());
      baseJsonBuilder.appendField("serverUUID", serverUuid);
      baseJsonBuilder.appendField("metricsVersion", METRICS_VERSION);
      JsonObjectBuilder.JsonObject data = baseJsonBuilder.build();
      scheduler.execute(
          () -> {
            try {
              // Send the data
              sendData(data);
            } catch (Exception e) {
              // Something went wrong! :(
              if (logErrors) {
                errorLogger.accept("Could not submit bStats metrics data", e);
              }
            }
          });
    }

    private void sendData(JsonObjectBuilder.JsonObject data) throws Exception {
      if (logSentData) {
        infoLogger.accept("Sent bStats metrics data: " + data.toString());
      }
      String url = String.format(REPORT_URL, platform);
      HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
      // Compress the data to save bandwidth
      byte[] compressedData = compress(data.toString());
      connection.setRequestMethod("POST");
      connection.addRequestProperty("Accept", "application/json");
      connection.addRequestProperty("Connection", "close");
      connection.addRequestProperty("Content-Encoding", "gzip");
      connection.addRequestProperty("Content-Length", String.valueOf(compressedData.length));
      connection.setRequestProperty("Content-Type", "application/json");
      connection.setRequestProperty("User-Agent", "Metrics-Service/1");
      connection.setDoOutput(true);
      try (DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream())) {
        outputStream.write(compressedData);
      }
      StringBuilder builder = new StringBuilder();
      try (BufferedReader bufferedReader =
               new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
        String line;
        while ((line = bufferedReader.readLine()) != null) {
          builder.append(line);
        }
      }
      if (logResponseStatusText) {
        infoLogger.accept("Sent data to bStats and received response: " + builder);
      }
    }

    /** Checks that the class was properly relocated. */
    private void checkRelocation() {
      // You can use the property to disable the check in your test environment
      if (System.getProperty("bstats.relocatecheck") == null
          || !System.getProperty("bstats.relocatecheck").equals("false")) {
        // Maven's Relocate is clever and changes strings, too. So we have to use this
        // little "trick" ... :D
        final String defaultPackage =
            new String(new byte[] {'o', 'r', 'g', '.', 'b', 's', 't', 'a', 't', 's'});
        final String examplePackage =
            new String(new byte[] {'y', 'o', 'u', 'r', '.', 'p', 'a', 'c', 'k', 'a', 'g', 'e'});
        // We want to make sure no one just copy & pastes the example and uses the wrong
        // package names
        if (MetricsBase.class.getPackage().getName().startsWith(defaultPackage)
            || MetricsBase.class.getPackage().getName().startsWith(examplePackage)) {
          throw new IllegalStateException("bStats Metrics class has not been relocated correctly!");
        }
      }
    }

    /**
     * Gzips the given string.
     *
     * @param str The string to gzip.
     * @return The gzipped string.
     */
    private static byte[] compress(final String str) throws IOException {
      if (str == null) {
        return null;
      }
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      try (GZIPOutputStream gzip = new GZIPOutputStream(outputStream)) {
        gzip.write(str.getBytes(StandardCharsets.UTF_8));
      }
      return outputStream.toByteArray();
    }
  }

  public static class SimplePie extends CustomChart {

    private final Callable<String> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public SimplePie(String chartId, Callable<String> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    protected JsonObjectBuilder.JsonObject getChartData() throws Exception {
      String value = callable.call();
      if (value == null || value.isEmpty()) {
        // Null = skip the chart
        return null;
      }
      return new JsonObjectBuilder().appendField("value", value).build();
    }
  }

  public static class MultiLineChart extends CustomChart {

    private final Callable<Map<String, Integer>> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public MultiLineChart(String chartId, Callable<Map<String, Integer>> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    protected JsonObjectBuilder.JsonObject getChartData() throws Exception {
      JsonObjectBuilder valuesBuilder = new JsonObjectBuilder();
      Map<String, Integer> map = callable.call();
      if (map == null || map.isEmpty()) {
        // Null = skip the chart
        return null;
      }
      boolean allSkipped = true;
      for (Map.Entry<String, Integer> entry : map.entrySet()) {
        if (entry.getValue() == 0) {
          // Skip this invalid
          continue;
        }
        allSkipped = false;
        valuesBuilder.appendField(entry.getKey(), entry.getValue());
      }
      if (allSkipped) {
        // Null = skip the chart
        return null;
      }
      return new JsonObjectBuilder().appendField("values", valuesBuilder.build()).build();
    }
  }

  public static class AdvancedPie extends CustomChart {

    private final Callable<Map<String, Integer>> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public AdvancedPie(String chartId, Callable<Map<String, Integer>> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    protected JsonObjectBuilder.JsonObject getChartData() throws Exception {
      JsonObjectBuilder valuesBuilder = new JsonObjectBuilder();
      Map<String, Integer> map = callable.call();
      if (map == null || map.isEmpty()) {
        // Null = skip the chart
        return null;
      }
      boolean allSkipped = true;
      for (Map.Entry<String, Integer> entry : map.entrySet()) {
        if (entry.getValue() == 0) {
          // Skip this invalid
          continue;
        }
        allSkipped = false;
        valuesBuilder.appendField(entry.getKey(), entry.getValue());
      }
      if (allSkipped) {
        // Null = skip the chart
        return null;
      }
      return new JsonObjectBuilder().appendField("values", valuesBuilder.build()).build();
    }
  }

  public static class SimpleBarChart extends CustomChart {

    private final Callable<Map<String, Integer>> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public SimpleBarChart(String chartId, Callable<Map<String, Integer>> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    protected JsonObjectBuilder.JsonObject getChartData() throws Exception {
      JsonObjectBuilder valuesBuilder = new JsonObjectBuilder();
      Map<String, Integer> map = callable.call();
      if (map == null || map.isEmpty()) {
        // Null = skip the chart
        return null;
      }
      for (Map.Entry<String, Integer> entry : map.entrySet()) {
        valuesBuilder.appendField(entry.getKey(), new int[] {entry.getValue()});
      }
      return new JsonObjectBuilder().appendField("values", valuesBuilder.build()).build();
    }
  }

  public static class AdvancedBarChart extends CustomChart {

    private final Callable<Map<String, int[]>> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public AdvancedBarChart(String chartId, Callable<Map<String, int[]>> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    protected JsonObjectBuilder.JsonObject getChartData() throws Exception {
      JsonObjectBuilder valuesBuilder = new JsonObjectBuilder();
      Map<String, int[]> map = callable.call();
      if (map == null || map.isEmpty()) {
        // Null = skip the chart
        return null;
      }
      boolean allSkipped = true;
      for (Map.Entry<String, int[]> entry : map.entrySet()) {
        if (entry.getValue().length == 0) {
          // Skip this invalid
          continue;
        }
        allSkipped = false;
        valuesBuilder.appendField(entry.getKey(), entry.getValue());
      }
      if (allSkipped) {
        // Null = skip the chart
        return null;
      }
      return new JsonObjectBuilder().appendField("values", valuesBuilder.build()).build();
    }
  }

  public static class DrilldownPie extends CustomChart {

    private final Callable<Map<String, Map<String, Integer>>> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public DrilldownPie(String chartId, Callable<Map<String, Map<String, Integer>>> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    public JsonObjectBuilder.JsonObject getChartData() throws Exception {
      JsonObjectBuilder valuesBuilder = new JsonObjectBuilder();
      Map<String, Map<String, Integer>> map = callable.call();
      if (map == null || map.isEmpty()) {
        // Null = skip the chart
        return null;
      }
      boolean reallyAllSkipped = true;
      for (Map.Entry<String, Map<String, Integer>> entryValues : map.entrySet()) {
        JsonObjectBuilder valueBuilder = new JsonObjectBuilder();
        boolean allSkipped = true;
        for (Map.Entry<String, Integer> valueEntry : map.get(entryValues.getKey()).entrySet()) {
          valueBuilder.appendField(valueEntry.getKey(), valueEntry.getValue());
          allSkipped = false;
        }
        if (!allSkipped) {
          reallyAllSkipped = false;
          valuesBuilder.appendField(entryValues.getKey(), valueBuilder.build());
        }
      }
      if (reallyAllSkipped) {
        // Null = skip the chart
        return null;
      }
      return new JsonObjectBuilder().appendField("values", valuesBuilder.build()).build();
    }
  }

  public abstract static class CustomChart {

    private final String chartId;

    protected CustomChart(String chartId) {
      if (chartId == null) {
        throw new IllegalArgumentException("chartId must not be null");
      }
      this.chartId = chartId;
    }

    public JsonObjectBuilder.JsonObject getRequestJsonObject(
        BiConsumer<String, Throwable> errorLogger, boolean logErrors) {
      JsonObjectBuilder builder = new JsonObjectBuilder();
      builder.appendField("chartId", chartId);
      try {
        JsonObjectBuilder.JsonObject data = getChartData();
        if (data == null) {
          // If the data is null we don't send the chart.
          return null;
        }
        builder.appendField("data", data);
      } catch (Throwable t) {
        if (logErrors) {
          errorLogger.accept("Failed to get data for custom chart with id " + chartId, t);
        }
        return null;
      }
      return builder.build();
    }

    protected abstract JsonObjectBuilder.JsonObject getChartData() throws Exception;
  }

  public static class SingleLineChart extends CustomChart {

    private final Callable<Integer> callable;

    /**
     * Class constructor.
     *
     * @param chartId The id of the chart.
     * @param callable The callable which is used to request the chart data.
     */
    public SingleLineChart(String chartId, Callable<Integer> callable) {
      super(chartId);
      this.callable = callable;
    }

    @Override
    protected JsonObjectBuilder.JsonObject getChartData() throws Exception {
      int value = callable.call();
      if (value == 0) {
        // Null = skip the chart
        return null;
      }
      return new JsonObjectBuilder().appendField("value", value).build();
    }
  }

  /**
   * An extremely simple JSON builder.
   *
   * <p>While this class is neither feature-rich nor the most performant one, it's sufficient enough
   * for its use-case.
   */
  public static class JsonObjectBuilder {

    private StringBuilder builder = new StringBuilder();

    private boolean hasAtLeastOneField = false;

    public JsonObjectBuilder() {
      builder.append("{");
    }

    /**
     * Appends a null field to the JSON.
     *
     * @param key The key of the field.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendNull(String key) {
      appendFieldUnescaped(key, "null");
      return this;
    }

    /**
     * Appends a string field to the JSON.
     *
     * @param key The key of the field.
     * @param value The value of the field.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendField(String key, String value) {
      if (value == null) {
        throw new IllegalArgumentException("JSON value must not be null");
      }
      appendFieldUnescaped(key, "\"" + escape(value) + "\"");
      return this;
    }

    /**
     * Appends an integer field to the JSON.
     *
     * @param key The key of the field.
     * @param value The value of the field.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendField(String key, int value) {
      appendFieldUnescaped(key, String.valueOf(value));
      return this;
    }

    /**
     * Appends an object to the JSON.
     *
     * @param key The key of the field.
     * @param object The object.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendField(String key, JsonObject object) {
      if (object == null) {
        throw new IllegalArgumentException("JSON object must not be null");
      }
      appendFieldUnescaped(key, object.toString());
      return this;
    }

    /**
     * Appends a string array to the JSON.
     *
     * @param key The key of the field.
     * @param values The string array.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendField(String key, String[] values) {
      if (values == null) {
        throw new IllegalArgumentException("JSON values must not be null");
      }
      String escapedValues =
          Arrays.stream(values)
              .map(value -> "\"" + escape(value) + "\"")
              .collect(Collectors.joining(","));
      appendFieldUnescaped(key, "[" + escapedValues + "]");
      return this;
    }

    /**
     * Appends an integer array to the JSON.
     *
     * @param key The key of the field.
     * @param values The integer array.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendField(String key, int[] values) {
      if (values == null) {
        throw new IllegalArgumentException("JSON values must not be null");
      }
      String escapedValues =
          Arrays.stream(values).mapToObj(String::valueOf).collect(Collectors.joining(","));
      appendFieldUnescaped(key, "[" + escapedValues + "]");
      return this;
    }

    /**
     * Appends an object array to the JSON.
     *
     * @param key The key of the field.
     * @param values The integer array.
     * @return A reference to this object.
     */
    public JsonObjectBuilder appendField(String key, JsonObject[] values) {
      if (values == null) {
        throw new IllegalArgumentException("JSON values must not be null");
      }
      String escapedValues =
          Arrays.stream(values).map(JsonObject::toString).collect(Collectors.joining(","));
      appendFieldUnescaped(key, "[" + escapedValues + "]");
      return this;
    }

    /**
     * Appends a field to the object.
     *
     * @param key The key of the field.
     * @param escapedValue The escaped value of the field.
     */
    private void appendFieldUnescaped(String key, String escapedValue) {
      if (builder == null) {
        throw new IllegalStateException("JSON has already been built");
      }
      if (key == null) {
        throw new IllegalArgumentException("JSON key must not be null");
      }
      if (hasAtLeastOneField) {
        builder.append(",");
      }
      builder.append("\"").append(escape(key)).append("\":").append(escapedValue);
      hasAtLeastOneField = true;
    }

    /**
     * Builds the JSON string and invalidates this builder.
     *
     * @return The built JSON string.
     */
    public JsonObject build() {
      if (builder == null) {
        throw new IllegalStateException("JSON has already been built");
      }
      JsonObject object = new JsonObject(builder.append("}").toString());
      builder = null;
      return object;
    }

    /**
     * Escapes the given string like stated in https://www.ietf.org/rfc/rfc4627.txt.
     *
     * <p>This method escapes only the necessary characters '"', '\'. and '\u0000' - '\u001F'.
     * Compact escapes are not used (e.g., '\n' is escaped as "\u000a" and not as "\n").
     *
     * @param value The value to escape.
     * @return The escaped value.
     */
    private static String escape(String value) {
      final StringBuilder builder = new StringBuilder();
      for (int i = 0; i < value.length(); i++) {
        char c = value.charAt(i);
        if (c == '"') {
          builder.append("\\\"");
        } else if (c == '\\') {
          builder.append("\\\\");
        } else if (c <= '\u000F') {
          builder.append("\\u000").append(Integer.toHexString(c));
        } else if (c <= '\u001F') {
          builder.append("\\u00").append(Integer.toHexString(c));
        } else {
          builder.append(c);
        }
      }
      return builder.toString();
    }

    /**
     * A super simple representation of a JSON object.
     *
     * <p>This class only exists to make methods of the {@link JsonObjectBuilder} type-safe and not
     * allow a raw string inputs for methods like {@link JsonObjectBuilder#appendField(String,
     * JsonObject)}.
     */
    public static class JsonObject {

      private final String value;

      private JsonObject(String value) {
        this.value = value;
      }

      @Override
      public String toString() {
        return value;
      }
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\PlayerUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.Permissions;

import java.util.List;

/**
 * Utility class for handling player-related operations and configurations.
 */
public class PlayerUtil {

  private static final FileConfiguration config = GensPlus.getInstance().getConfig();

  /**
   * Retrieves the limit value for a player.
   *
   * @param player The player for which to retrieve the limit.
   * @return The limit value.
   */
  private static Double getLimit(Player player, String permissionPrefix, String use,
                                 String configKey) {
    if (config.getBoolean(use + ".use-permissions")) {
      List<String> permissions = player.getEffectivePermissions().stream()
          .map(permission -> permission.getPermission().toLowerCase())
          .filter(permission -> permission.startsWith(permissionPrefix))
          .toList();

      if (permissions.isEmpty()) {
        return config.getDouble(configKey);
      }

      return permissions.stream()
          .map(permission -> permission.substring(permissionPrefix.length()).replace(',', '.'))
          .map(Double::parseDouble)
          .max(Double::compareTo)
          .orElse(config.getDouble(configKey));
    }

    return config.getDouble(configKey);
  }

  /**
   * Retrieves the multiplier value for a player.
   *
   * @param player The player for which to retrieve the multiplier.
   * @return The multiplier value.
   */
  public static Double getMultiplier(Player player) {
    return getLimit(player, Permissions.SELL_MULTIPLIER.getPermission(), "multiplier",
        Config.MULTIPLIER_DEFAULT_MULTIPLIER.getPath());
  }

  /**
   * Retrieves the generator limit for a player.
   *
   * @param player The player for which to retrieve the generator limit.
   * @return The generator limit value.
   */
  public static Integer getGeneratorLimitPerPlayer(Player player) {
    return getLimit(player, Permissions.GENERATOR_LIMIT.getPermission(), "limits.per-player",
        Config.LIMIT_PER_PLAYER_DEFAULT_LIMIT.getPath()).intValue();
  }

  /**
   * Retrieves the chunk radius for a player.
   *
   * @param player The player for which to retrieve the chunk radius.
   * @return The chunk radius value.
   */
  public static Integer getRadius(Player player) {
    return getLimit(player, Permissions.CHUNK_RADIUS.getPermission(), "radius",
        Config.CHUNK_RADIUS_DEFAULT_RADIUS.getPath()).intValue();
  }

  /**
   * Gets the item currently held in the player's main hand.
   *
   * @param player The player for whom to retrieve the held item.
   * @return The item held in the player's main hand.
   */
  public static ItemStack getHeldItem(Player player) {
    return ServerVersion.isServerVersionAbove(ServerVersion.V1_8)
        ? player.getInventory().getItemInMainHand() : player.getInventory().getItemInHand();
  }

  /**
   * Gets the item currently held in the player's off hand.
   *
   * @param player The player for whom to retrieve the held off-hand item.
   * @return The item held in the player's off hand.
   */
  public static ItemStack getOffHeldItem(Player player) {
    return ServerVersion.isServerVersionAbove(ServerVersion.V1_8)
        ? player.getInventory().getItemInOffHand() : player.getInventory().getItemInHand();
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\SellUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import io.github.bananapuncher714.nbteditor.NBTEditor;
import net.milkbowl.vault.economy.Economy;
import org.bukkit.Material;
import org.bukkit.entity.Player;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.models.GeneratorsData;
import xyz.arcadiadevs.gensplus.models.WandData;
import xyz.arcadiadevs.gensplus.models.events.ActiveEvent;
import xyz.arcadiadevs.gensplus.models.events.SellEvent;
import xyz.arcadiadevs.gensplus.tasks.EventLoop;
import xyz.arcadiadevs.gensplus.utils.config.message.Messages;

/**
 * The SellUtil class provides utility methods for selling generator drops in GensPlus.
 * It contains a static method to sell generator drops for a player.
 */
public class SellUtil {

  /**
   * Sells generator drops for a player.
   *
   * @param player The player who wants to sell their generator drops.
   */
  public static void sellAll(Player player, Inventory inventory, boolean... isGui) {
    int totalSellAmount = 0;
    final ActiveEvent event = EventLoop.getActiveEvent();

    final double multiplier = (event.event() instanceof SellEvent
        ? event.event().getMultiplier() * PlayerUtil.getMultiplier(player)
        : 1.0 * PlayerUtil.getMultiplier(player));

    // Iterate through the player's inventory to find generator drops
    for (int i = 0; i < inventory.getSize(); i++) {
      ItemStack item = inventory.getItem(i);

      if (item == null) {
        continue;
      }

      if (NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")) {
        int tier = NBTEditor.getInt(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier");
        final GeneratorsData generatorsData = GensPlus.getInstance().getGeneratorsData();
        final GeneratorsData.Generator generator = generatorsData.getGenerator(tier);

        final double itemAmount = item.getAmount();
        final double sellPrice = generator.sellPrice();
        double sellAmount = (sellPrice * itemAmount * multiplier);
        totalSellAmount += sellAmount;
        inventory.setItem(i, null);
      } else {
        if (isGui.length > 0 && isGui[0]) {
          player.getInventory().addItem(item);
        }
      }
    }

    // Perform the selling operation if there are generator drops to sell
    if (totalSellAmount <= 0) {
      Messages.NOTHING_TO_SELL.format().send(player);
      return;
    }

    final Economy economy = GensPlus.getInstance().getEcon();

    economy.depositPlayer(player, totalSellAmount);

    Messages.SUCCESSFULLY_SOLD.format(
            "price", economy.format(totalSellAmount))
        .send(player);
  }


  /**
   * Sells generator drops for a player.
   *
   * @param player    The player who wants to sell their generator drops.
   * @param inventory The inventory to sell from.
   */
  public static void sellWand(Player player, Inventory inventory, double wandMultiplier,
                              WandData.Wand wand) {
    int totalSellAmount = 0;
    final ActiveEvent event = EventLoop.getActiveEvent();

    final double multiplier = (event.event() instanceof SellEvent
        ? event.event().getMultiplier() * PlayerUtil.getMultiplier(player)
        : 1.0 * PlayerUtil.getMultiplier(player)) * wandMultiplier;

    long totalItems = 0;

    for (int i = 0; i < inventory.getSize(); i++) {
      ItemStack item = inventory.getItem(i);

      if (item == null) {
        continue;
      }

      if (!NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier")) {
        continue;
      }

      int tier = NBTEditor.getInt(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier");
      final GeneratorsData generatorsData = GensPlus.getInstance().getGeneratorsData();
      final GeneratorsData.Generator generator = generatorsData.getGenerator(tier);

      long itemAmount = item.getAmount();
      totalItems += itemAmount;
      final double sellPrice = generator.sellPrice();
      double sellAmount = (sellPrice * itemAmount * multiplier);
      totalSellAmount += (int) sellAmount;
      inventory.removeItem(item);
    }

    if (totalSellAmount <= 0) {
      Messages.NOTHING_TO_SELL.format().send(player);
      return;
    }

    final Economy economy = GensPlus.getInstance().getEcon();
    wand.setUses(wand.getUses() <= -1 ? -1 : wand.getUses() - 1);

    wand.setTotalEarned(wand.getTotalEarned() + totalSellAmount);
    wand.setTotalItemsSold(wand.getTotalItemsSold() + totalItems);

    economy.depositPlayer(player, totalSellAmount);

    Messages.SUCCESSFULLY_SOLD.format(
            "price", economy.format(totalSellAmount),
              "amount", String.valueOf(totalItems)
        )
        .send(player);

    Messages.SUCCESSFULLY_SOLD.format(
            "price", economy.format(totalSellAmount),
            "amount", String.valueOf(totalItems)
        )
        .sendInActionBar(player);
  }

  /**
   * Sells the generator drop the player is holding.
   *
   * @param player The player who wants to sell their generator drop.
   */
  public static void sellHand(Player player) {

    final ActiveEvent event = EventLoop.getActiveEvent();

    final double multiplier = (event.event() instanceof SellEvent
        ? event.event().getMultiplier() * PlayerUtil.getMultiplier(player)
        : 1.0 * PlayerUtil.getMultiplier(player));

    ItemStack item = player.getInventory().getItemInMainHand();
    final boolean isAir = item.getType() == Material.AIR;

    if (!NBTEditor.contains(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier") || isAir) {
      Messages.NOTHING_TO_SELL.format().send(player);
      return;
    }

    int tier = NBTEditor.getInt(item, NBTEditor.CUSTOM_DATA, "gensplus", "spawnitem", "tier");
    final GeneratorsData generatorsData = GensPlus.getInstance().getGeneratorsData();
    final GeneratorsData.Generator generator = generatorsData.getGenerator(tier);

    final double itemAmount = item.getAmount();
    final double sellPrice = generator.sellPrice();
    double sellAmount = (sellPrice * itemAmount * multiplier);

    player.getInventory().setItem(player.getInventory().getHeldItemSlot(), null);

    final Economy economy = GensPlus.getInstance().getEcon();

    economy.depositPlayer(player, sellAmount);

    Messages.SUCCESSFULLY_SOLD.format(
            "price", economy.format(sellAmount))
        .send(player);

  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\ServerVersion.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import lombok.Getter;
import org.bukkit.Bukkit;

/**
 * An enum representing the server version.
 */
@Getter
public enum ServerVersion {
  UNKNOWN, V1_7, V1_8, V1_9, V1_10, V1_11, V1_12, V1_13, V1_14, V1_15, V1_16, V1_17, V1_18, V1_19,
  V1_20, V1_21, V1_22;

  /**
   * -- GETTER --
   *  Returns the server version as an enum value.
   *
   * @return The server version.
   */
  private static final ServerVersion serverVersion;
  private static final String serverReleaseVersion;
  private static final String serverPackageVersion;
  private static final String serverPackagePath;

  static {
    serverPackagePath = Bukkit.getServer().getClass().getPackage().getName();
    serverPackageVersion = serverPackagePath.substring(serverPackagePath.lastIndexOf('.') + 1);
    serverReleaseVersion = (serverPackageVersion.indexOf('R') != -1)
        ? serverPackageVersion.substring(serverPackageVersion.indexOf('R') + 1) : "";
    serverVersion = getVersion();
  }

  /**
   * Returns the server version as an enum value.
   *
   * @return The server version.
   */
  private static ServerVersion getVersion() {
    for (ServerVersion version : values()) {
      if (serverPackageVersion.toUpperCase().startsWith(version.name())) {
        return version;
      }
    }
    return UNKNOWN;
  }

  /**
   * Checks if this server version is less than the specified version.
   *
   * @param other The version to compare against.
   * @return True if this server version is less than the specified version, otherwise false.
   */
  public boolean isLessThan(ServerVersion other) {
    return (ordinal() < other.ordinal());
  }

  /**
   * Checks if this server version is at or below the specified version.
   *
   * @param other The version to compare against.
   * @return True if this server version is at or below the specified version, otherwise false.
   */
  public boolean isAtOrBelow(ServerVersion other) {
    return (ordinal() <= other.ordinal());
  }

  /**
   * Checks if this server version is greater than the specified version.
   *
   * @param other The version to compare against.
   * @return True if this server version is greater than the specified version, otherwise false.
   */
  public boolean isGreaterThan(ServerVersion other) {
    return (ordinal() > other.ordinal());
  }

  /**
   * Checks if this server version is at least the specified version.
   *
   * @param other The version to compare against.
   * @return True if this server version is at least the specified version, otherwise false.
   */
  public boolean isAtLeast(ServerVersion other) {
    return (ordinal() >= other.ordinal());
  }

  /**
   * Returns the server version as a string.
   *
   * @return The server version string.
   */
  public static String getServerVersionString() {
    return serverPackageVersion;
  }

  /**
   * Returns the release number of the server version.
   *
   * @return The release number of the server version.
   */
  public static String getVersionReleaseNumber() {
    return serverReleaseVersion;
  }

  /**
   * Checks if the current server version matches the specified version.
   *
   * @param version The version to check against.
   * @return True if the current server version matches the specified version, otherwise false.
   */
  public static boolean isServerVersion(ServerVersion version) {
    return (serverVersion == version);
  }

  /**
   * Checks if the current server version matches any of the specified versions.
   *
   * @param versions The versions to check against.
   * @return True if the current server version matches any of the specified versions, otherwise false.
   */
  public static boolean isServerVersion(ServerVersion... versions) {
    for (ServerVersion v : versions) {
      if (v == serverVersion) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if the current server version is above the specified version.
   *
   * @param version The version to compare against.
   * @return True if the current server version is above the specified version, otherwise false.
   */
  public static boolean isServerVersionAbove(ServerVersion version) {
    return (serverVersion.ordinal() > version.ordinal());
  }

  /**
   * Checks if the current server version is at least the specified version.
   *
   * @param version The version to compare against.
   * @return True if the current server version is at least the specified version, otherwise false.
   */
  public static boolean isServerVersionAtLeast(ServerVersion version) {
    return (serverVersion.ordinal() >= version.ordinal());
  }

  /**
   * Checks if the current server version is at or below the specified version.
   *
   * @param version The version to compare against.
   * @return True if the current server version is at or below the specified version, otherwise false.
   */
  public static boolean isServerVersionAtOrBelow(ServerVersion version) {
    return (serverVersion.ordinal() <= version.ordinal());
  }

  /**
   * Checks if the current server version is below the specified version.
   *
   * @param version The version to compare against.
   * @return True if the current server version is below the specified version, otherwise false.
   */
  public static boolean isServerVersionBelow(ServerVersion version) {
    return (serverVersion.ordinal() < version.ordinal());
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\SkyblockUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

import com.bgsoftware.superiorskyblock.api.SuperiorSkyblockAPI;
import com.bgsoftware.superiorskyblock.api.island.Island;
import com.iridium.iridiumskyblock.api.IridiumSkyblockAPI;
import java.util.List;
import java.util.UUID;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.request.AddonRequestBuilder;
import xyz.arcadiadevs.gensplus.utils.config.Config;
import xyz.arcadiadevs.gensplus.utils.config.objects.GensPerLevel;

/**
 * A utility class for handling various interactions with different Skyblock plugins.
 */
public class SkyblockUtil {

  /**
   * Calculate the generator limit based on the player's island level and the configuration.
   *
   * @param player The player for whom to calculate the generator limit.
   * @return The calculated generator limit.
   */
  public static long calculateLimit(Player player) {
    long level = getIslandLevel(player.getLocation(), player);
    long limit = 0;

    List<GensPerLevel> gensPerLevel = GensPerLevel.factory(
        Config.LIMIT_PER_ISLAND_GENS_PER_LEVEL.getStringList()
    );

    int min = gensPerLevel.stream()
        .mapToInt(GensPerLevel::from)
        .min()
        .orElse(0);

    for (int i = min; i <= level; i++) {
      final int finalLevel = i;

      GensPerLevel gpl = gensPerLevel.stream()
          .filter(g -> g.isIn(finalLevel))
          .findFirst()
          .orElse(null);

      if (gpl != null) {
        limit += gpl.gain();
      }
    }

    return limit;
  }

  /**
   * Get the ID of the island at a specific location.
   *
   * @param location The location to check for an island.
   * @return The ID of the island, or null if no island is found.
   */
  public static String getIslandId(Location location) {
    String islandId = null;

    try {
      if (Bukkit.getPluginManager().isPluginEnabled("BentoBox")) {
        islandId = getIdBentobox(location);
      } else if (Bukkit.getPluginManager().isPluginEnabled("SuperiorSkyblock2")) {
        islandId = getIdSuperiorSkyblock(location);
      } else if (Bukkit.getPluginManager().isPluginEnabled("IridiumSkyblock")) {
        islandId = getIdIridiumSkyblock(location);
      }
    } catch (NullPointerException ignored) {
      return islandId;
    }

    return islandId;
  }

  /**
   * Get the ID of the island using SuperiorSkyblock2.
   *
   * @param location The location to check for an island.
   * @return The ID of the island, or null if no island is found.
   */
  @Nullable
  public static String getIdSuperiorSkyblock(Location location) {
    Island island = SuperiorSkyblockAPI.getIslandAt(location);

    if (island == null) {
      return null;
    }

    return island.getUniqueId().toString();
  }

  /**
   * Get the ID of the island using BentoBox.
   *
   * @param location The location to check for an island.
   * @return The ID of the island, or null if no island is found.
   */
  @Nullable
  public static String getIdBentobox(Location location) {
    return BentoBox.getInstance()
        .getIslands()
        .getIslandAt(location)
        .orElse(null)
        .getUniqueId();
  }

  /**
   * Get the ID of the island using IridiumSkyblock.
   *
   * @param location The location to check for an island.
   * @return The ID of the island, or null if no island is found.
   */
  @Nullable
  public static String getIdIridiumSkyblock(Location location) {
    return String.valueOf(
        IridiumSkyblockAPI.getInstance()
            .getIslandViaLocation(location)
            .orElse(null)
            .getId()
    );
  }

  /**
   * Get the island level based on the location and player using the appropriate plugin.
   *
   * @param location The location to check for an island.
   * @param player   The player associated with the island.
   * @return The island level, or null if no island or level is found.
   */
  @Nullable
  public static Long getIslandLevel(Location location, Player player) {
    if (Bukkit.getPluginManager().isPluginEnabled("BentoBox")) {
      return getLevelBentobox(location, player);
    } else if (Bukkit.getPluginManager().isPluginEnabled("SuperiorSkyblock2")) {
      return getLevelSuperiorSkyblock(location);
    } else if (Bukkit.getPluginManager().isPluginEnabled("IridiumSkyblock")) {
      return getLevelIridiumSkyblock(location);
    }

    return null;
  }

  /**
   * Retrieve the island level from the BentoBox plugin.
   *
   * @param location The location to check for an island.
   * @param player The player associated with the island.
   * @return The island level, or null if not available.
   */
  @Nullable
  public static Long getLevelBentobox(Location location, Player player) {
    try {
      return (long) new AddonRequestBuilder()
          .addon("Level")
          .label("island-level")
          .addMetaData("world-name", location.getWorld().getName())
          .addMetaData("player", player.getUniqueId())
          .request();
    } catch (NullPointerException ex) {
      return null;
    }
  }

  /**
   * Retrieve the island level from the SuperiorSkyblock2 plugin.
   *
   * @param location The location to check for an island.
   * @return The island level, or null if not available.
   */
  @Nullable
  public static Long getLevelSuperiorSkyblock(Location location) {
    String islandId = getIslandId(location);

    if (islandId == null) {
      return null;
    }

    return SuperiorSkyblockAPI.getGrid()
        .getIslandByUUID(UUID.fromString(islandId))
        .getIslandLevel()
        .longValue();
  }

  /**
   * Retrieve the island level from the IridiumSkyblock plugin.
   *
   * @param location The location to check for an island.
   * @return The island level, or null if not available.
   */
  @Nullable
  public static Long getLevelIridiumSkyblock(Location location) {
    String islandId = getIslandId(location);

    if (islandId == null) {
      return null;
    }

    return (long) IridiumSkyblockAPI.getInstance()
        .getIslandById(Integer.parseInt(islandId))
        .orElseThrow()
        .getLevel();
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\TimeUtil.java
================================================================================

package xyz.arcadiadevs.gensplus.utils;

/**
 * The TimeUtil class provides utility methods for time-related operations.
 */
public class TimeUtil {

  /**
   * Parses a time string into the corresponding number of ticks.
   *
   * @param time The time string to parse.
   * @return The number of ticks.
   * @throws IllegalArgumentException if an invalid unit is specified in the time string.
   */
  public static long parseTime(String time) {
    long totalTicks = 0;

    String[] parts = time.split("\\s+");

    for (String part : parts) {
      char unit = part.charAt(part.length() - 1);
      int value = Integer.parseInt(part.substring(0, part.length() - 1));

      switch (unit) {
        case 's' -> totalTicks += value * 20L; // 20 ticks per second
        case 'm' -> totalTicks += value * 20L * 60L; // 20 ticks per second, 60 seconds per minute
        case 'h' -> totalTicks += value * 20L * 60L
            * 60L; // 20 ticks per second, 60 seconds per minute, 60 minutes per hour

        // You can add additional cases for other units if needed (e.g., 'd' for days)
        default ->
            throw new IllegalArgumentException("Invalid unit specified in despawn time: " + unit);
      }
    }

    return totalTicks;
  }

  /**
   * Converts the specified number of ticks into a formatted time string in the format "HH:MM:SS".
   *
   * @param ticks The number of ticks to convert.
   * @return The formatted time string.
   */
  public static String ticksToTime(long ticks) {
    long seconds = ticks / 20L;
    long minutes = seconds / 60L;
    long hours = minutes / 60L;
    return String.format("%02d:%02d:%02d", hours, minutes % 60, seconds % 60);
  }

  /**
   * Parses a time string into the corresponding number of milliseconds.
   *
   * @param time The time string to parse.
   * @return The number of milliseconds.
   * @throws IllegalArgumentException if an invalid unit is specified in the time string.
   */
  public static long parseTimeMillis(String time) {
    long totalMillis = 0;

    String[] parts = time.split("\\s+");

    for (String part : parts) {
      char unit = part.charAt(part.length() - 1);
      int value = Integer.parseInt(part.substring(0, part.length() - 1));

      switch (unit) {
        case 's' -> totalMillis += value * 1000L; // 1000 milliseconds per second
        case 'm' -> totalMillis +=
            value * 1000L * 60L; // 1000 milliseconds per second, 60 seconds per minute
        case 'h' -> totalMillis += value * 1000L * 60L
            * 60L; // 1000 milliseconds per second, 60 seconds per minute, 60 minutes per hour

        // You can add additional cases for other units if needed (e.g., 'd' for days)
        default ->
            throw new IllegalArgumentException("Invalid unit specified in despawn time: " + unit);
      }
    }

    return totalMillis;
  }

  /**
   * Converts the specified number of milliseconds into a formatted time string in the
   * format "HH:MM:SS".
   *
   * @param millis The number of milliseconds to convert.
   * @return The formatted time string.
   */
  public static String millisToTime(long millis) {
    long seconds = millis / 1000L;
    long minutes = seconds / 60L;
    long hours = minutes / 60L;
    return String.format("%02d:%02d:%02d", hours, minutes % 60, seconds % 60);
  }

}


================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\config\Config.java
================================================================================

package xyz.arcadiadevs.gensplus.utils.config;

import com.awaitquality.api.spigot.chat.ChatUtil;
import lombok.Getter;
import org.bukkit.configuration.file.FileConfiguration;
import xyz.arcadiadevs.gensplus.GensPlus;

import java.util.ArrayList;
import java.util.Map;

/**
 * The ConfigManager class provides functionality for handling the configuration file in GensPlus.
 */
public enum Config {
  ITEM_DESPAWN_TIME("item-despawn-time", "5m"),
  CAN_DROPS_BE_PLACED("can-items-be-placed", false),
  CAN_DROPS_BE_USED_IN_CRAFTING("can-items-be-used-in-crafting", false),
  CAN_DROPS_BE_USED_IN_SMELTING("can-items-be-used-in-smelting", false),
  CAN_DROPS_BE_USED_IN_ENCHANTING("can-items-be-used-in-enchanting", false),
  DISABLE_GENERATORS_WHEN_OFFLINE("disable-generators-when-offline", true),
  DISABLED_WORLDS("disabled-worlds", new ArrayList<String>()),
  INSTANT_PICKUP("instant-pickup", false),
  ON_JOIN_ENABLED("on-join.enabled", true),
  ON_JOIN_GENERATOR_TIER("on-join.generator-tier", 1),
  ON_JOIN_GENERATOR_AMOUNT("on-join.generator-amount", 3),
  GENERATOR_UPGRADE_SNEAK("guis.upgrade-gui.sneak-required", true),
  GENERATOR_UPGRADE_ACTION("guis.upgrade-gui.action", "RIGHT_CLICK_BLOCK"),
  SELL_WAND_ACTION_SNEAK("wands.sell-wand.sneak-required", true),
  SELL_WAND_ACTION("wands.sell-wand.action", "RIGHT_CLICK_BLOCK"),
  SELL_WAND_UNLIMITED_USES_PREFIX("wands.sell-wand.unlimited-uses-prefix", ""),
  SELL_COMMAND_ENABLED("sell-command.enabled", true),
  SELL_COMMAND_ALLIASES("sell-command.aliases", new ArrayList<String>()),
  LIMIT_PER_ISLAND_ENABLED("limits.per-island.enabled", false),
  LIMIT_PER_ISLAND_GENS_PER_LEVEL("limits.per-island.gens-per-level", new ArrayList<>()),
  LIMIT_PER_PLAYER_ENABLED("limits.per-player.enabled", false),
  LIMIT_PER_PLAYER_USE_PERMISSIONS("limits.per-player.use-permissions", false),
  LIMIT_PER_PLAYER_USE_COMMANDS("limits.per-player.use-commands", true),
  LIMIT_PER_PLAYER_DEFAULT_LIMIT("limits.per-player.default-limit", 20),
  LIMIT_PER_PLAYER_UNLIMITED_PLACEHOLDER("limits.per-player.unlimited-placeholder", "unlimited"),
  CHUNK_RADIUS_ENABLED("radius.enabled", true),
  CHUNK_RADIUS_USE_PERMISSIONS("radius.use-permissions", true),
  CHUNK_RADIUS_DEFAULT_RADIUS("radius.default-radius", 1),
  MULTIPLIER_USE_PERMISSIONS("multiplier.use-permissions", true),
  MULTIPLIER_DEFAULT_MULTIPLIER("multiplier.default-multiplier", 1),
  GUIS_GENERATORS_GUI_ENABLED("guis.generators-gui.enabled", true),
  GUIS_GENERATORS_GUI_TITLE("guis.generators-gui.title", "Generators"),
  GUIS_GENERATORS_GUI_ROWS("guis.generators-gui.rows", 6),
  GUIS_GENERATORS_GUI_BORDER_ENABLED("guis.generators-gui.border.enabled", true),
  GUIS_GENERATORS_GUI_BORDER_MATERIAL("guis.generators-gui.border.material",
      "WHITE_STAINED_GLASS_PANE"),
  GUIS_GENERATORS_GUI_BORDER_NAME("guis.generators-gui.border.name", " "),
  GUIS_GENERATORS_GUI_NEXT_PAGE_MATERIAL("guis.generators-gui.material.next-page",
      "ARROW"),
  GUIS_GENERATORS_GUI_PREVIOUS_PAGE_MATERIAL("guis.generators-gui.material.previous-page",
      "ARROW"),
  GUIS_GENERATORS_GUI_CLOSE_BUTTON_MATERIAL("guis.generators-gui.material.close-button",
      "BARRIER"),
  GUIS_UPGRADE_GUI_ENABLED("guis.upgrade-gui.enabled", true),
  GUIS_UPGRADE_GUI_UPGRADE_ONE_FIRST_LINE("guis.upgrade-gui.upgradeOne.first-line",
      "&e &nClick to upgrade generator!&e "),
  GUIS_UPGRADE_GUI_UPGRADE_ONE_LORE("guis.upgrade-gui.upgradeOne.lore", new ArrayList<String>()),
  GUIS_UPGRADE_GUI_UPGRADE_ALL_FIRST_LINE("guis.upgrade-gui.upgradeAll.first-line",
      "&e &nClick to upgrade all generators!&e "),
  GUIS_UPGRADE_GUI_UPGRADE_ALL_LORE("guis.upgrade-gui.upgradeAll.lore", new ArrayList<String>()),
  GUIS_UPGRADE_GUI_TITLE("guis.upgrade-gui.title", "Upgrade Generator"),
  GUIS_UPGRADE_GUI_ROWS("guis.upgrade-gui.rows", 3),
  GUIS_SELL_GUI_ENABLED("guis.sell-gui.enabled", true),
  GUIS_SELL_GUI_TITLE("guis.sell-gui.title", "Sell Items"),
  GUIS_SELL_GUI_ROWS("guis.sell-gui.rows", 3),
  HOLOGRAMS_ENABLED("holograms.enabled", false),
  HOLOGRAMS_VIEW_DISTANCE("holograms.view-distance", 2000),
  EVENTS_TIME_BETWEEN_EVENTS("events.time-between-events", "1h"),
  EVENTS_EVENT_DURATION("events.event-duration", "2m"),
  EVENTS_BROADCAST_ENABLED("events.broadcast.enabled", true),
  EVENTS_DROP_EVENT_ENABLED("events.drop-event.enabled", true),
  EVENTS_DROP_EVENT_NAME("events.drop-event.name", "Drop Event"),
  EVENTS_DROP_EVENT_MULTIPLIER("events.drop-event.multiplier", 2),
  EVENTS_SELL_EVENT_ENABLED("events.sell-event.enabled", true),
  EVENTS_SELL_EVENT_NAME("events.sell-event.name", "Sell Event"),
  EVENTS_SELL_EVENT_MULTIPLIER("events.sell-event.multiplier", 2),
  EVENTS_SPEED_EVENT_ENABLED("events.speed-event.enabled", true),
  EVENTS_SPEED_EVENT_NAME("events.speed-event.name", "Speed Event"),
  EVENTS_SPEED_EVENT_MULTIPLIER("events.speed-event.multiplier", 2),
  PARTICLES_ENABLED("particles.enabled", true),
  PARTICLES_TYPE("particles.type", "FIREWORKS_SPARK"),
  PARTICLES_SOUND("particles.sound", "ENTITY_FIREWORK_ROCKET_BLAST"),
  DEFAULT_LORE("default-lore", new ArrayList<String>()),
  DEFAULT_ITEM_SPAWN_LORE("default-item-spawn-lore", new ArrayList<String>()),
  DEFAULT_HOLOGRAM_LINES("default-hologram-lines", new ArrayList<String>()),
  DEVELOPER_OPTIONS("developer-options.enabled", false),
  GENERATORS("generators", new ArrayList<Map<?, ?>>());

  @Getter
  private final String path;

  @Getter
  private final Object defaultValue;

  Config(String path, Object defaultValue) {
    this.path = path;
    this.defaultValue = defaultValue;
  }

  public Object get(boolean format) {
    FileConfiguration config = GensPlus.getInstance().getConfig();

    if (!config.contains(path)) {
      config.set(path, defaultValue);
      GensPlus.getInstance().saveConfig();
    }

    Object value = config.get(this.path);

    if (format && !(value instanceof String)) {
      throw new IllegalArgumentException("Cannot format non-string value!");
    }

    return format ? ChatUtil.translate(value.toString()) : value;
  }

  public Object get() {
    return get(false);
  }

  public boolean getBoolean() {
    return (boolean) get();
  }

  public int getInt() {
    return (int) get();
  }

  public double getDouble() {
    return (double) get();
  }

  public String getString() {
    return (String) get();
  }

  public String getStringFormatted() {
    return (String) getFormatted();
  }

  public ArrayList<String> getStringList() {
    return (ArrayList<String>) get();
  }

  public ArrayList<Map<?, ?>> getMapList() {
    return (ArrayList<Map<?, ?>>) get();
  }

  public ArrayList<Integer> getIntegerList() {
    return (ArrayList<Integer>) get();
  }

  public ArrayList<Double> getDoubleList() {
    return (ArrayList<Double>) get();
  }

  public ArrayList<Boolean> getBooleanList() {
    return (ArrayList<Boolean>) get();
  }

  public Object getFormatted() {
    return get(true);
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\config\Permissions.java
================================================================================

package xyz.arcadiadevs.gensplus.utils.config;

/**
 * The Permissions class contains all the permissions used in GensPlus.
 */
public enum Permissions {
  ADMIN("gensplus.admin"),
  GENERATORS_GUI("gensplus.generator.open"),
  GENERATOR_GIVE("gensplus.admin.give"),
  GENERATOR_GIVE_ALL("gensplus.admin.give.all"),
  GENERATOR_RELOAD("gensplus.admin.reload"),
  START_EVENT("gensplus.admin.startevent"),
  STOP_EVENT("gensplus.admin.stopevent"),
  GENERATOR_DROPS_SELL_ALL("gensplus.drop.sell.all"),
  GENERATOR_DROPS_SELL_HAND("gensplus.drop.sell.hand"),
  GENERATOR_DROPS_SELL_GUI("gensplus.drop.sell.gui"),
  SELL_MULTIPLIER("gensplus.sell.multiplier."),
  GENERATOR_LIMIT("gensplus.limit."),
  CHUNK_RADIUS("gensplus.radius."),
  SET_LIMIT("gensplus.admin.setlimit"),
  ADD_LIMIT("gensplus.admin.addlimit"),
  GIVE_WAND("gensplus.admin.givewand");

  private final String permission;

  Permissions(String permission) {
    this.permission = permission;
  }

  public String getPermission(String... args) {
    String perm = permission;

    // Find how many {} are in the permission
    int count = countBrackets(permission);

    if (count != args.length) {
      throw new IllegalArgumentException("Invalid number of arguments");
    }

    for (String arg : args) {
      perm = permission.replace("{}", arg);
    }

    return perm;
  }

  private int countBrackets(String string) {
    int count = 0;
    for (int i = 0; i < string.length(); i++) {
      if (string.charAt(i) == '{') {
        count++;
      } else if (string.charAt(i) == '}') {
        count--;
      }
    }
    return count;
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\config\message\Messages.java
================================================================================

package xyz.arcadiadevs.gensplus.utils.config.message;

import lombok.Getter;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import xyz.arcadiadevs.gensplus.GensPlus;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * The Messages class contains all the messages used in GensPlus.
 */
public enum Messages {

  // List of Messages with their corresponding default values
  NO_PERMISSION("no-permission", "&cError> &7You don't have permission to do that!"),
  PLUGIN_RELOADED("plugin-reloaded", "&9GensPlus> &7Plugin reloaded!"),
  PLAYER_NOT_FOUND("player-not-found", "&cError> &7Player not found!"),
  TOO_FAST("too-fast", "&cError> &7You are doing that too fast!"),
  INVALID_GENERATOR_TIER("invalid-generator-tier", "&cError> &7Invalid generator tier!"),
  INVALID_FORMAT("invalid-format", "&cError> &7Invalid format!"),
  GENERATOR_GIVEN("generator-given",
      "&9GensPlus> &7You gave &a%amount% &7generator(s) of tier &a%tier% &7to &a%targetPlayer%"),
  GENERATOR_RECEIVED("generator-received",
      "&9GensPlus> &7You received &a%amount% &7generator(s) of tier &a%tier%"),
  LIMIT_REACHED("limit-reached",
      "&cError> &7You have reached the limit of &c%limit% &7generators!"),
  EVENT_STARTED("event-started", "&9GensPlus> &7%event% has started and will end in &e&n%time%!"),
  EVENT_ENDED("event-ended",
      "&9GensPlus> &7%event% has ended and a new event will be started in &e&n%time%!"),
  EVENT_FORCE_ENDED("event-force-ended",
      "&9GensPlus> &7Event has been force ended! New event will be started in &e&n%time%!"),
  EVENT_ALREADY_RUNNING("event-already-running", "&cError> &7An event is already running!"),
  EVENT_NOT_FOUND("event-not-found", "&cError> &7Event not found!"),
  SUCCESSFULLY_UPGRADED("successfully-upgraded",
      "&9GensPlus> &7Successfully upgraded your generator to tier &a%tier%!"),
  SUCCESSFULLY_SOLD("successfully-sold", "&9GensPlus> &7Successfully sold drops for &a%price%"),
  SUCCESSFULLY_SOLD_ACTION_BAR("successfully-sold-action-bar",
      "&cSuccessfully sold &a%amount% &cdrops for &a%price%&c!"),
  NOT_ENOUGH_MONEY("not-enough-money",
      "&cError> &7You don't have enough money to do that! (%currentBalance%/&a%price%&7)"),
  NOTHING_TO_SELL("nothing-to-sell", "&cError> &7You don't have any drops to sell!"),
  SUCCESSFULLY_DESTROYED("successfully-destroyed",
      "&9GensPlus> &7Successfully destroyed generator!"
  ),
  SUCCESSFULLY_PLACED("successfully-placed",
      "&9GensPlus> &7Successfully placed generator tier %tier%!"
  ),
  SUCCESSFULLY_BOUGHT("successfully-bought",
      "&9GensPlus> &7Successfully bought generator tier %tier% for %price%!"
  ),
  REACHED_MAX_TIER("reached-max-tier",
      "&cError> &7You have reached the maximum tier of the generator!"
  ),
  NOT_ENOUGH_ARGUMENTS("not-enough-arguments", "&cError> &7Not enough arguments!"),
  INVALID_AMOUNT("invalid-amount", "&cError> &7Invalid amount!"),
  GENERATOR_GIVEN_ALL("generator-given-all",
      "&9GensPlus> &7You gave &a%amount% &7generator(s) of tier &a%tier% &7to all players! (&a%count%&7)"
  ),
  DEFAULT_MESSAGE("default-message", "&9GensPlus> &7This server is running GensPlus &av%version%"
  ),
  CANNOT_PLACE_IN_WORLD("cannot-place-in-world",
      "&cError> &7You cannot place a generator in this world!"
  ),
  NOT_YOUR_GENERATOR_DESTROY("not-your-generator-destroy",
      "&cError> &7You cannot destroy a generator that is not yours!"
  ),
  NOT_YOUR_GENERATOR_UPGRADE("not-your-generator-upgrade",
      "&cError> &7You cannot upgrade a generator that is not yours!"
  ),
  ONLY_PLAYER_CAN_EXECUTE_COMMAND("only-player-can-execute-command",
      "&cError> &7Only a player can execute this command!"
  ),
  SELL_WAND_GIVEN("sell-wand-given", "&9GensPlus> &7You have been given a sell wand!"),
  SELL_WAND_RECEIVED("sell-wand-received", "&9GensPlus> &7You have received a sell wand!"),
  UPGRADE_WAND_GIVEN("upgrade-wand-given", "&9GensPlus> &7You have been given an upgrade wand!"),
  UPGRADE_WAND_RECEIVED("upgrade-wand-received",
      "&9GensPlus> &7You have received an upgrade wand!"
  ),
  WAND_BROKE("wand-broke", "&cError> &7Your wand broke!"),
  LIMIT_UPDATED("limit-updated",
      "&9GensPlus> &7You have changed %player%'s gens limit to &a%limit%&7!");

  private final String key;

  @Getter
  private final String defaultMessage;

  @Getter
  private String message;

  /**
   * Initializes the Messages enum by loading the messages.yml file.
   */
  public static void init() {
    final File file = new File(GensPlus.getInstance().getDataFolder(), "messages.yml");
    final FileConfiguration config = YamlConfiguration.loadConfiguration(file);

    for (Messages message : Messages.values()) {
      message.message = config.getString(message.key, message.defaultMessage);
    }

    try {
      config.save(file);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  Messages(String key, String defaultMessage) {
    this.key = key;
    this.defaultMessage = defaultMessage;
  }

  /**
   * Returns the path of the message.
   *
   * @return The path of the message.
   */
  public String getPath() {
    return name().toLowerCase().replace("_", "-");
  }

  /**
   * Returns a cached list containing the default message.
   *
   * @return A list containing the default message.
   */
  public List<String> getCached() {
    return new ArrayList<>(Collections.singletonList(message));
  }

  /**
   * Formats the message with provided placeholders.
   *
   * @param placeholders The values to replace the placeholders in the message.
   * @return A formatted PlayerMessage with the placeholders replaced.
   */
  public PlayerMessage format(Object... placeholders) {
    return new PlayerMessage(this).format(placeholders);
  }

  /**
   * Returns the message with placeholders replaced by provided values.
   *
   * @param replacements Pairs of placeholder-replacement values
   *                     (in the format of [placeholder, replacement]).
   * @return The message with placeholders replaced.
   */
  public String getMessage(String... replacements) {
    String msg = message;
    for (int i = 0; i < replacements.length - 1; i += 2) {
      msg = msg.replace(replacements[i], replacements[i + 1]);
    }
    return msg;
  }

}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\config\message\PlayerMessage.java
================================================================================

package xyz.arcadiadevs.gensplus.utils.config.message;

import com.awaitquality.api.spigot.chat.ChatUtil;
import java.util.Collection;
import java.util.List;
import java.util.logging.Level;
import net.md_5.bungee.api.ChatMessageType;
import net.md_5.bungee.api.chat.TextComponent;
import net.md_5.bungee.chat.ComponentSerializer;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import xyz.arcadiadevs.gensplus.GensPlus;
import xyz.arcadiadevs.gensplus.utils.ActionBarUtil;
import xyz.arcadiadevs.gensplus.utils.ServerVersion;

/**
 * PlayerMessage.java handles the formatting and sending of messages to players.
 */
public class PlayerMessage {
  private final Messages message;
  private final List<String> format;

  /**
   * Used employer send messages with placeholders and color codes
   *
   * @param message Message employer send employer any player
   */
  public PlayerMessage(Messages message) {
    format = (this.message = message).getCached();
  }

  public PlayerMessage format(Object... placeholders) {
    format.replaceAll(str -> apply(str, placeholders));
    return this;
  }

  private String apply(String str, Object... placeholders) {
    for (int k = 0; k < placeholders.length; k += 2) {
      str = str.replace("%" + placeholders[k] + "%", placeholders[k + 1].toString());
    }

    return ChatUtil.translate(str);
  }

  public String getAsString() {
    StringBuilder builder = new StringBuilder();
    boolean notEmpty = false;
    for (String str : format) {
      if (notEmpty) {
        builder.append("\n");
      }
      builder.append(str);
      notEmpty = true;
    }
    return builder.toString();
  }

  public void send(Collection<? extends Player> senders) {
    senders.forEach(this::send);
  }

  public void send(CommandSender sender) {
    if (format.isEmpty()) {
      return;
    }

    format.forEach(sender::sendMessage);
  }

  public void send(boolean broadcast) {
    if (format.isEmpty() && !broadcast) {
      return;
    }

    format.forEach(Bukkit::broadcastMessage);
  }

  public void sendInActionBar(Player player) {
    ActionBarUtil.sendActionBar(player, format.get(0));
  }

  public void sendAsJson(Player player) {
    for (String message : format) {
      try {
        // TODO: Fix 1.8 support
        if (ServerVersion.isServerVersionAtLeast(ServerVersion.V1_9)) {
          player.spigot().sendMessage(ChatMessageType.CHAT, ComponentSerializer.parse(message));
          continue;
        }

        send(player);
      } catch (RuntimeException exception) {
        GensPlus.getInstance().getLogger().log(Level.WARNING,
            "Could not parse raw message sent to player. Make sure it has the right syntax");
        GensPlus.getInstance().getLogger().log(Level.WARNING, "Message: " + message);
        exception.printStackTrace();
      }
    }
  }
}



================================================================================
File: .\src\main\java\xyz\arcadiadevs\gensplus\utils\config\objects\GensPerLevel.java
================================================================================

package xyz.arcadiadevs.gensplus.utils.config.objects;

import java.util.ArrayList;
import java.util.List;

public record GensPerLevel(int from, int to, int gain) {

  public boolean isIn(int level) {
    return level >= from && level <= to;
  }

  public static List<GensPerLevel> factory(ArrayList<String> gensPerLevel) {
    ArrayList<GensPerLevel> gensPerLevelList = new ArrayList<>();

    for (String gens : gensPerLevel) {
      String[] split = gens.split(":");

      gensPerLevelList.add(new GensPerLevel(
          Integer.parseInt(split[0]),
          Integer.parseInt(split[1]),
          Integer.parseInt(split[2]))
      );
    }

    return gensPerLevelList;
  }

  @Override
  public String toString() {
    return "GensPerLevel{"
        + "from=" + from
        + ", to=" + to
        + ", gain=" + gain
        + '}';
  }
}



================================================================================
File: .\src\main\resources\config.yml
================================================================================

# Specify the time after which the item will despawn from the time it was spawned.
# The despawn time can be specified in the following format variations:
# - "1h" for 1 hour
# - "5m" for 5 minutes
# - "1h 5m" for 1 hour and 5 minutes
# - "1h 5m 5s" for 1 hour and 5 minutes 5 seconds
item-despawn-time: "5m"

# If set to false, players will not be able to place generator drops.
# If player places generator drop, it will lose all it
# values and will be turned into a normal block.
can-drops-be-placed: false

# If set to false, players will not be able to use generator drops or
# generator blocks in crafting recipes.
can-drops-be-used-in-crafting: false

# If set to false, players will not be able to use generator drops or
# generator blocks for smelting.
can-items-be-used-in-smelting: false

# If set to false, players will not be able to use generator drops or
# generator blocks in enchanting.
can-drops-be-used-in-enchanting: false

# If set to true, generators will not spawn drops when
# the owner of the generator is offline.
disable-generators-when-offline: true

# Each world listed here will have generators disabled.
# If empty, all worlds will have generators enabled.
disabled-worlds: []

# Should we give a generator instantly to players inventory
# when they break a generator? If set to false, the generator
# will be dropped on the ground.
instant-pickup: false

on-join:
  # If enabled is set to false, when player joins, he will not receive
  # the generator.
  enabled: true

  # What tier of generator should player be given on join.
  generator-tier: 1

  # How many generators should player be given on join.
  generator-amount: 3

sell-command:
  # If enabled is set to false, the command will not be registered.
  enabled: true

  # The command that will be used to sell all drops in inventory.
  aliases:
    - "sellall"

limits:
  # Per-player generator limits
  per-player:
    # If enabled is set to false, the limit will not be checked.
    enabled: false

    # Should we use permissions for generator limit?
    # If set to true, you will be able to set specific
    # limits for each player. [gensplus.limit.<amount>]
    # (ex: gensplus.limit.20)
    use-permissions: false

    # [OVERRIDES USE-PERMISSIONS]
    # Should we use commands for generator limit?
    # If set to true, you can set specific limits for each player
    # by using the command /gensplus setlimit <player> <limit>
    # (ex: /gensplus setlimit Notch 20).
    use-commands: true

    # The default generator limit for all players
    default-limit: 20

    # The placeholder that will be used in the limit placeholder
    # if the limit-settings.enabled is set to false.
    unlimited-placeholder: "unlimited"

  # Per island generator limits. Supports IridiumSkyblock, SuperiorSkyblock,
  # and Bentobox (only with Bentobox Levels addon)
  per-island:
    enabled: false

    # How many generators should an island get per level.
    # Format: "<startLevel>:<endLevel>:<amount>"
    # Example: "1:5:1" means that between levels 1 and 5, the island will get 1 generator.
    # Example: "6:10:2" means that between levels 6 and 10, the island will get 2 generators.
    gens-per-level:
      - "1:5:1"
      - "6:10:2"

# Radius defines in how many blocks around the generator the player
# needs to be in order for the generator to be active.
radius:
  # If not enabled, generators will always be active, even if
  # player is not in the chunk radius.
  enabled: true

  # Should we use permissions for chunk radius?
  # If set to true, you will be able to set specific
  # chunk radius for each player. [gensplus.radius.<amount>]
  # (ex: gensplus.radius.5)
  use-permissions: true

  # The default radius used if player has no permission
  # or if use-permission is set to false.
  default-radius: 50

multiplier:
  # Should we use permissions for multiplier?
  # If set to true, you will be able to set specific
  # multipliers for each player. [gensplus.sell.multiplier.<amount>]
  # (ex: gensplus.sell.multiplier.2)
  use-permissions: true

  # The default multiplier for all players
  default-multiplier: 1

wands:
  sell-wand:
    enabled: true

    # Action that will open the gui if enabled or upgrade the generator if upgrade gui
    # is disabled. Available actions (case sensitive!):
    # [LEFT_CLICK_BLOCK, RIGHT_CLICK_BLOCK]
    action: "RIGHT_CLICK_BLOCK"

    # If sneak-required is set to true, the player will need to sneak in order to
    # open the gui or upgrade the generator.
    sneak-required: true

    # The material of the sell wand
    material: "BLAZE_ROD"

    # The name of the sell wand
    name: "&e&lSell Wand"

    # Unlimited uses prefix (if "uses" in game is set to -1, it will be replaced with this prefix)
    unlimited-uses-prefix: ""

    # The lore of the sell wand
    lore:
      - ""
      - "&7Right click on a chest or a hopper to sell all drops!"
      - "&e &fUses: &a%uses%"
      - "&e &fMultiplier: &a%multiplier%"
      - ""

guis:
  # Gui to view generators by a command
  generators-gui:
    # If enabled is set to false, the command will not be registered.
    enabled: true

    # Title of the gui
    title: "Generators"

    # Number of rows in the gui
    rows: 6

    # The material of the buttons in the gui
    material:
      next-page: "ARROW"
      previous-page: "ARROW"
      close-button: "BARRIER"

    border:
      # If enabled is set to false, the border won't be displayed.
      enabled: true

      # Material of the border
      material: "WHITE_STAINED_GLASS_PANE"

      # Name of the border
      name: " "

  # Gui when upgrading generator
  upgrade-gui:
    # If enabled is set to false, upgrade gui will not be displayed
    # and the generator will be upgraded instantly by Shift + Right Click-ing.
    # on the generator.
    enabled: true

    # Action that will open the gui if enabled or upgrade the generator if upgrade gui
    # is disabled. Available actions (case sensitive!):
    # [LEFT_CLICK_BLOCK, RIGHT_CLICK_BLOCK]
    action: "RIGHT_CLICK_BLOCK"

    # If sneak-required is set to true, the player will need to sneak in order to
    # open the gui or upgrade the generator.
    sneak-required: true

    upgradeOne:
      first-line: "&e &nClick to upgrade generator!&e "
      # If lore is not specified, the default lore will be used.
      # The default lore can be specified in the following format:
      # - %tier%" equals to the generator's tier
      # - %speed%" is the generator's speed of spawning items
      # - %price%" is the price of generator
      # - %sellPrice%" is the sell price of generator drop
      # - %spawnItem%" equals to what item will generator spawn
      # - %blockType%" equals to block type of generator
      # - %nextTier% equals to the next tier of generator
      # - %nextSpeed% equals to the next speed of generator
      # - %nextPrice% equals to the next price of generator
      # - %nextSellPrice% equals to the next sell price of generator
      # - %nextSpawnItem% equals to the next spawn item of generator
      # - %nextBlockType% equals to the next block type of generator
      lore:
        - ""
        - "&fMoney: &a%money%"
        - "&fUpgrade Price: &a%upgradePrice%"
        - ""
        - "&eCurrent Details:"
        - "&e &fTier: &a%tier%"
        - "&e &fSpeed: &a%speed%"
        - "&e &fPrice: &a%price%"
        - "&e &fSell Price: &a%sellPrice%"
        - ""
        - "&eNext Details:"
        - "&e &fTier: &a%nextTier%"
        - "&e &fSpeed: &a%nextSpeed%"
        - "&e &fPrice: &a%nextPrice%"
        - "&e &fSell Price: &a%nextSellPrice%"
        - ""

    upgradeAll:
        first-line: "&e &nClick to upgrade all generators!&e "
        # If lore is not specified, the default lore will be used.
        # The default lore can be specified in the following format:
        # - %tier%" equals to the generator's tier
        # - %speed%" is the generator's speed of spawning items
        # - %price%" is the price of generator
        # - %sellPrice%" is the sell price of generator drop
        # - %spawnItem%" equals to what item will generator spawn
        # - %blockType%" equals to block type of generator
        # - %nextTier% equals to the next tier of generator
        # - %nextSpeed% equals to the next speed of generator
        # - %nextPrice% equals to the next price of generator
        # - %nextSellPrice% equals to the next sell price of generator
        # - %nextSpawnItem% equals to the next spawn item of generator
        # - %nextBlockType% equals to the next block type of generator
        lore:
            - ""
            - "&fMoney: &a%money%"
            - "&fUpgrade Price: &a%upgradePrice%"
            - ""
            - "&eCurrent Details:"
            - "&e &fTier: &a%tier%"
            - "&e &fSpeed: &a%speed%"
            - "&e &fPrice: &a%price%"
            - "&e &fSell Price: &a%sellPrice%"
            - ""
            - "&eNext Details:"
            - "&e &fTier: &a%nextTier%"
            - "&e &fSpeed: &a%nextSpeed%"
            - "&e &fPrice: &a%nextPrice%"
            - "&e &fSell Price: &a%nextSellPrice%"
            - ""

    # Title of the gui
    title: "Upgrade Generator"

    # Number of rows in the gui
    rows: 3

  sell-gui:
    # If enabled is set to false, the command will not be registered.
    enabled: true

    # Title of the gui
    title: "Sell Drops"

    # Number of rows in the gui
    rows: 3

holograms:
  # If enabled is set to false, holograms will not be shown
  enabled: true

  # The hologram view distance
  view-distance: 300

events:
  # time can be specified in the following format variations:
  # - "1h" for 1 hour
  # - "5m" for 5 minutes
  # - "1h 5m" for 1 hour and 5 minutes
  # - "1h 5m 5s" for 1 hour and 5 minutes and 5 seconds

  # Time duration between events
  time-between-events: "1h"

  # Duration of each event
  event-duration: "2m"

  broadcast:
    # If enabled is set to false, there will be no broadcast messages.
    enabled: true

  drop-event:
    # If enabled is set to false, the event will not be registered.
    enabled: true

    # Name of the drop event
    name: "Drop Event"

    # Multiplier for the event
    multiplier: 2

  sell-event:
    # If enabled is set to false, the event will not be registered.
    enabled: true

    # Name of the sell event
    name: "Sell Event"

    # Multiplier for the event
    multiplier: 2

  speed-event:
    # If enabled is set to false, the event will not be registered.
    enabled: true

    # Name of the speed event
    name: "Speed Event"

    # Multiplier for the event
    multiplier: 2

particles:
  # If enabled is set to false, particles will not be displayed upon upgrade.
  enabled: true

  # Type of the particle. Make sure to use particles
  # that are supported by your server version, otherwise,
  # the particles will not be displayed. You can find
  # all supported particles here:
  # https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Particle.html
  type: "FIREWORKS_SPARK"

  # Sound that will be played upon upgrade.
  # You can find all supported sounds here:
  # https://github.com/dieterblancke/DonatorJoinPlus/blob/master/spigot/src/main/java/com/dbsoftwares/djp/spigot/utils/XSound.java
  sound: "ENTITY_FIREWORK_ROCKET_BLAST"

# If lore is not specified, the default lore will be used.
# The default lore can be specified in the following format:
# - %tier%" equals to the generator's tier
# - %speed%" is the generator's speed of spawning items
# - %price%" is the price of generator
# - %sellPrice%" is the sell price of generator drop
# - %spawnItem%" equals to what item will generator spawn
# - %blockType%" equals to block type of generator
default-lore:
  - "&7Place down to start generating items!"
  - ""
  - "&e&l &6Tier: &7%tier%"
  - "&e&l &6Speed: &7%speed%"
  - "&e&l &6Price: &a%price%"
  - "&e&l &6Sell Price: &a%sellPrice%"
  - ""
  - "&e&l &6Spawn Item: &7%spawnItem%"
  - "&e&l &6Block Type: &7%blockType%"

# If itemSpawnLore is not specified, the default item spawn lore will be used.
# The default item spawn lore can be specified in the following format:
# - %sellPrice%" is the sell price of the generator drop
default-item-spawn-lore:
  - "&7Type in chat &e/selldrops &6hand&8/&6all"
  - "&7to sell the drops for &e%sellPrice%"

# If hologramLines is not specified, the default hologram lines will be used.
# The default hologram lines can be specified in the following format:
# Lines that will be displayed above the generator
# Lines can be specified in the following format:
# %name% will be replaced with the name of the generator
# %tier% will be replaced with the tier of the generator
# %speed% will be replaced with the speed of the generator
# %spawnItem% will be replaced with the item that generator spawns
# %sellPrice% will be replaced with the sell price of the generator
default-hologram-lines:
  - "&a%name%"
  - "&7Tier: &a%tier%"
  - "&7Spawns each &a%speed% &7seconds &a%spawnItem%"
  - "&7Sells for &a%sellPrice%"

# generators represent the generators that will be added in the gui,
# name is the name of the generator
# tier is the tier of the generator (each generator must have a unique tier)
# price is the price of the generator
# sellPrice is the sell price of the generator drop
# speed is the speed of the generator (how often it will spawn items)
# spawnItem is the item that generator will spawn
# blockType is the block type of the generator
# lore is the lore of the generator (if not specified, the default lore will be used)
# itemSpawnLore is the lore of the generator drop (if not specified, the default item spawn lore will be used)
# hologramLines is the hologram lines of the generator (if not specified, the default hologram lines will be used)
# dropDisplayName is the display name of the generator drop
# instantBreak is whether the generator can be instantly broken by SHIT + RIGHT-clicking or not
generators:
  - name: "&e&lWheat Generator"
    tier: 1
    price: 1000.0
    sellPrice: 10.0
    speed: 20
    spawnItem: "WHEAT"
    blockType: "HAY_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&e%name%"
      - "&7Tier: &e%tier%"
      - "&7Spawns each &e%speed% &7seconds &e%spawnItem%"
      - "&7Sells for &e%sellPrice%"
    dropDisplayName: "&e&lWheat Drop"
    instantBreak: false
  - name: "&a&lMelon Generator"
    tier: 2
    price: 2000.0
    sellPrice: 20.0
    speed: 20
    spawnItem: "MELON_SLICE"
    blockType: "MELON"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&a%name%"
      - "&7Tier: &a%tier%"
      - "&7Spawns each &a%speed% &7seconds &a%spawnItem%"
      - "&7Sells for &a%sellPrice%"
    dropDisplayName: "&a&lMelon Drop"
    instantBreak: false
  - name: "&8&lCoal Generator"
    tier: 3
    price: 3000.0
    sellPrice: 25.0
    speed: 20
    spawnItem: "COAL"
    blockType: "COAL_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&8%name%"
      - "&7Tier: &8%tier%"
      - "&7Spawns each &8%speed% &7seconds &8%spawnItem%"
      - "&7Sells for &8%sellPrice%"
    dropDisplayName: "&8&lCoal Drop"
    instantBreak: false
  - name: "&8&lCoal Block Generator"
    tier: 4
    price: 4000.0
    sellPrice: 50.0
    speed: 20
    spawnItem: "COAL_BLOCK"
    blockType: "COAL_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&8%name%"
      - "&7Tier: &8%tier%"
      - "&7Spawns each &8%speed% &7seconds &8%spawnItem%"
      - "&7Sells for &8%sellPrice%"
    dropDisplayName: "&8&lCoal Block Drop"
    instantBreak: false
  - name: "&7&lIron Generator"
    tier: 5
    price: 5000.0
    sellPrice: 75.0
    speed: 20
    spawnItem: "IRON_INGOT"
    blockType: "IRON_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&7%name%"
      - "&7Tier: &7%tier%"
      - "&7Spawns each &7%speed% &7seconds &7%spawnItem%"
      - "&7Sells for &7%sellPrice%"
    dropDisplayName: "&7&lIron Drop"
    instantBreak: false
  - name: "&7&lIron Block Generator"
    tier: 6
    price: 6000.0
    sellPrice: 100.0
    speed: 20
    spawnItem: "IRON_BLOCK"
    blockType: "IRON_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&7%name%"
      - "&7Tier: &7%tier%"
      - "&7Spawns each &7%speed% &7seconds &7%spawnItem%"
      - "&7Sells for &7%sellPrice%"
    dropDisplayName: "&f&lIron Block Drop"
    instantBreak: false
  - name: "&6&lGold Generator"
    tier: 7
    price: 7000.0
    sellPrice: 150.0
    speed: 20
    spawnItem: "GOLD_INGOT"
    blockType: "GOLD_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&6%name%"
      - "&7Tier: &6%tier%"
      - "&7Spawns each &6%speed% &7seconds &6%spawnItem%"
      - "&7Sells for &6%sellPrice%"
    dropDisplayName: "&6&lGold Drop"
    instantBreak: false
  - name: "&6&lGold Block Generator"
    tier: 8
    price: 8000.0
    sellPrice: 200.0
    speed: 20
    spawnItem: "GOLD_BLOCK"
    blockType: "GOLD_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&6%name%"
      - "&7Tier: &6%tier%"
      - "&7Spawns each &6%speed% &7seconds &6%spawnItem%"
      - "&7Sells for &6%sellPrice%"
    dropDisplayName: "&6&lGold Block Drop"
    instantBreak: false
  - name: "&4&lRedstone Generator"
    tier: 9
    price: 9000.0
    sellPrice: 300.0
    speed: 20
    spawnItem: "REDSTONE"
    blockType: "REDSTONE_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&4%name%"
      - "&7Tier: &4%tier%"
      - "&7Spawns each &4%speed% &7seconds &4%spawnItem%"
      - "&7Sells for &4%sellPrice%"
    dropDisplayName: "&4&lRedstone Drop"
    instantBreak: false
  - name: "&4&lRedstone Block Generator"
    tier: 10
    price: 10000.0
    sellPrice: 400.0
    speed: 20
    spawnItem: "REDSTONE_BLOCK"
    blockType: "REDSTONE_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&4%name%"
      - "&7Tier: &4%tier%"
      - "&7Spawns each &4%speed% &7seconds &4%spawnItem%"
      - "&7Sells for &4%sellPrice%"
    dropDisplayName: "&4&lRedstone Block Drop"
    instantBreak: false
  - name: "&b&lLapis Generator"
    tier: 11
    price: 11000.0
    sellPrice: 500.0
    speed: 20
    spawnItem: "LAPIS_LAZULI"
    blockType: "LAPIS_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&b%name%"
      - "&7Tier: &b%tier%"
      - "&7Spawns each &b%speed% &7seconds &b%spawnItem%"
      - "&7Sells for &b%sellPrice%"
    dropDisplayName: "&b&lLapis Drop"
    instantBreak: false
  - name: "&b&lLapis Block Generator"
    tier: 12
    price: 12000.0
    sellPrice: 600.0
    speed: 20
    spawnItem: "LAPIS_BLOCK"
    blockType: "LAPIS_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&b%name%"
      - "&7Tier: &b%tier%"
      - "&7Spawns each &b%speed% &7seconds &b%spawnItem%"
      - "&7Sells for &b%sellPrice%"
    dropDisplayName: "&b&lLapis Block Drop"
    instantBreak: false
  - name: "&3&lDiamond Generator"
    tier: 13
    price: 13000.0
    sellPrice: 700.0
    speed: 20
    spawnItem: "DIAMOND"
    blockType: "DIAMOND_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&3%name%"
      - "&7Tier: &3%tier%"
      - "&7Spawns each &3%speed% &7seconds &3%spawnItem%"
      - "&7Sells for &3%sellPrice%"
    dropDisplayName: "&3&lDiamond Drop"
    instantBreak: false
  - name: "&3&lDiamond Block Generator"
    tier: 14
    price: 14000.0
    sellPrice: 800.0
    speed: 20
    spawnItem: "DIAMOND_BLOCK"
    blockType: "DIAMOND_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&3%name%"
      - "&7Tier: &3%tier%"
      - "&7Spawns each &3%speed% &7seconds &3%spawnItem%"
      - "&7Sells for &3%sellPrice%"
    dropDisplayName: "&3&lDiamond Block Drop"
    instantBreak: false
  - name: "&a&lEmerald Generator"
    tier: 15
    price: 15000.0
    sellPrice: 900.0
    speed: 20
    spawnItem: "EMERALD"
    blockType: "EMERALD_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&a%name%"
      - "&7Tier: &a%tier%"
      - "&7Spawns each &a%speed% &7seconds &a%spawnItem%"
      - "&7Sells for &a%sellPrice%"
    dropDisplayName: "&a&lEmerald Drop"
    instantBreak: false
  - name: "&a&lEmerald Block Generator"
    tier: 16
    price: 16000.0
    sellPrice: 1000.0
    speed: 20
    spawnItem: "EMERALD_BLOCK"
    blockType: "EMERALD_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&a%name%"
      - "&7Tier: &a%tier%"
      - "&7Spawns each &a%speed% &7seconds &a%spawnItem%"
      - "&7Sells for &a%sellPrice%"
    dropDisplayName: "&a&lEmerald Block Drop"
    instantBreak: false
  - name: "&d&lQuartz Generator"
    tier: 17
    price: 17000.0
    sellPrice: 1100.0
    speed: 20
    spawnItem: "QUARTZ"
    blockType: "NETHER_QUARTZ_ORE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&d%name%"
      - "&7Tier: &d%tier%"
      - "&7Spawns each &d%speed% &7seconds &d%spawnItem%"
      - "&7Sells for &d%sellPrice%"
    dropDisplayName: "&d&lQuartz Drop"
    instantBreak: false
  - name: "&d&lQuartz Block Generator"
    tier: 18
    price: 18000.0
    sellPrice: 1200.0
    speed: 20
    spawnItem: "QUARTZ_BLOCK"
    blockType: "QUARTZ_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&d%name%"
      - "&7Tier: &d%tier%"
      - "&7Spawns each &d%speed% &7seconds &d%spawnItem%"
      - "&7Sells for &d%sellPrice%"
    dropDisplayName: "&d&lQuartz Block Drop"
    instantBreak: false
  - name: "&f&lNetherite Scrap Generator"
    tier: 19
    price: 19000.0
    sellPrice: 1300.0
    speed: 20
    spawnItem: "NETHERITE_SCRAP"
    blockType: "ANCIENT_DEBRIS"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&f%name%"
      - "&7Tier: &f%tier%"
      - "&7Spawns each &f%speed% &7seconds &f%spawnItem%"
      - "&7Sells for &f%sellPrice%"
    dropDisplayName: "&f&lNetherite Scrap Drop"
    instantBreak: false
  - name: "&f&lNetherite Ingot Generator"
    tier: 20
    price: 20000.0
    sellPrice: 1400.0
    speed: 20
    spawnItem: "NETHERITE_INGOT"
    blockType: "NETHERITE_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&f%name%"
      - "&7Tier: &f%tier%"
      - "&7Spawns each &f%speed% &7seconds &f%spawnItem%"
      - "&7Sells for &f%sellPrice%"
    dropDisplayName: "&f&lNetherite Ingot Drop"
    instantBreak: false
  - name: "&5&lAncient Debris Generator"
    tier: 21
    price: 21000.0
    sellPrice: 1500.0
    speed: 20
    spawnItem: "ANCIENT_DEBRIS"
    blockType: "ANCIENT_DEBRIS"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&5%name%"
      - "&7Tier: &5%tier%"
      - "&7Spawns each &5%speed% &7seconds &5%spawnItem%"
      - "&7Sells for &5%sellPrice%"
    dropDisplayName: "&5&lAncient Debris Drop"
    instantBreak: false
  - name: "&5&lNether Star Generator"
    tier: 22
    price: 22000.0
    sellPrice: 1600.0
    speed: 20
    spawnItem: "NETHER_STAR"
    blockType: "BEACON"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&5%name%"
      - "&7Tier: &5%tier%"
      - "&7Spawns each &5%speed% &7seconds &5%spawnItem%"
      - "&7Sells for &5%sellPrice%"
    dropDisplayName: "&5&lNether Star Drop"
    instantBreak: false
  - name: "&c&lCrying Obsidian Generator"
    tier: 23
    price: 23000.0
    sellPrice: 1700.0
    speed: 20
    spawnItem: "CRYING_OBSIDIAN"
    blockType: "CRYING_OBSIDIAN"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&c%name%"
      - "&7Tier: &c%tier%"
      - "&7Spawns each &c%speed% &7seconds &c%spawnItem%"
      - "&7Sells for &c%sellPrice%"
    dropDisplayName: "&c&lDragon Egg Drop"
    instantBreak: false
  - name: "&4&lObsidian Rose Generator"
    tier: 24
    price: 24000.0
    sellPrice: 1800.0
    speed: 20
    spawnItem: "WITHER_ROSE"
    blockType: "RESPAWN_ANCHOR"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&4%name%"
      - "&7Tier: &4%tier%"
      - "&7Spawns each &4%speed% &7seconds &4%spawnItem%"
      - "&7Sells for &4%sellPrice%"
    dropDisplayName: "&4&lWither Skeleton Skull Drop"
    instantBreak: false
  - name: "&8&lReinforced deepslate Generator"
    tier: 25
    price: 25000.0
    sellPrice: 1900.0
    speed: 20
    spawnItem: "REINFORCED_DEEPSLATE"
    blockType: "REINFORCED_DEEPSLATE"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&8%name%"
      - "&7Tier: &8%tier%"
      - "&7Spawns each &8%speed% &7seconds &8%spawnItem%"
      - "&7Sells for &8%sellPrice%"
    dropDisplayName: "&8&lReinforced deepslate Drop"
    instantBreak: false
  - name: "&6&lMagma Block Generator"
    tier: 26
    price: 26000.0
    sellPrice: 2000.0
    speed: 20
    spawnItem: "MAGMA_BLOCK"
    blockType: "MAGMA_BLOCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&6%name%"
      - "&7Tier: &6%tier%"
      - "&7Spawns each &6%speed% &7seconds &6%spawnItem%"
      - "&7Sells for &6%sellPrice%"
    dropDisplayName: "&6&lMagma Block Drop"
    instantBreak: false
  - name: "&4&lBedrock Generator"
    tier: 27
    price: 27000.0
    sellPrice: 2100.0
    speed: 20
    spawnItem: "BEDROCK"
    blockType: "BEDROCK"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&4%name%"
      - "&7Tier: &4%tier%"
      - "&7Spawns each &4%speed% &7seconds &4%spawnItem%"
      - "&7Sells for &4%sellPrice%"
    dropDisplayName: "&4&lBedrock Drop"
    instantBreak: true
  - name: "&e&lDragon Egg Generator"
    tier: 28
    price: 28000.0
    sellPrice: 2200.0
    speed: 20
    spawnItem: "DRAGON_EGG"
    blockType: "DRAGON_EGG"
    lore: []
    itemSpawnLore: []
    hologramLines:
      - "&e%name%"
      - "&7Tier: &e%tier%"
      - "&7Spawns each &e%speed% &7seconds &e%spawnItem%"
      - "&7Sells for &e%sellPrice%"
    dropDisplayName: "&e&lDragon Egg Drop"
    instantBreak: true

developer-options:
  debug: false


================================================================================
File: .\src\main\resources\messages.yml
================================================================================

# [general]
default-message: '&9GensPlus> This server is running GensPlus v%version%'
no-permission: "&cError> &7You don't have permission to do that!"
plugin-reloaded: "&9GensPlus> &7Plugin reloaded."
too-fast: "&cError> &7You are doing that too fast!"
player-not-found: "&cError> &7Player not found!"
not-enough-arguments: "&cError> &7Not enough arguments!"
only-player-can-execute-command: "&cError> &7Only player can execute this command!"
invalid-format: "&cError> &7Invalid format!"

# [limit-settings]
limit-reached: "&cError> &7You have reached the limit of &c%limit% &7generators!"
cannot-place-in-world: "&cError> &7You cannot place generators in this world!"
limit-updated: "&9GensPlus> &7You have changed %player%'s gens limit to &a%limit%&7!"

# [events]
event-started: "&9GensPlus> &7%event% has started and will end in &e&n%time%!"
event-ended: "&9GensPlus> &7%event% has ended and new event will be started in &e&n%time%!"
event-already-running: "&cError> &7An event is already running!"
event-force-ended: "&9GensPlus> &7Event has been force ended! New event will be started in &e&n%time%!"
event-not-found: "&cError> &7Event not found!"

# [generators]
successfully-upgraded: "&9GensPlus> &7Successfully upgraded your generator to tier &a%tier%!"
successfully-sold: "&9GensPlus> &7Successfully sold drops for &a%price%"
not-enough-money: "&cError> &7You don't have enough money to do that! %currentBalance%/%price%"
nothing-to-sell: "&cError> &7You don't have any drops to sell!"
invalid-generator-tier: "&cError> &7Invalid generator tier!"
successfully-destroyed: "&9GensPlus> &7Successfully destroyed generator!"
successfully-placed: "&9GensPlus> &7Successfully placed generator tier %tier%!"
successfully-bought: "&9GensPlus> &7Successfully bought generator tier %tier% for %price%!"
reached-max-tier: "&cError> &7You have reached the maximum tier of generator!"
not-your-generator-destroy: "&cError> &7You cannot destroy generator that is not yours!"
not-your-generator-upgrade: "&cError> &7You cannot upgrade generator that is not yours!"

# [admin]
generator-given: "&9GensPlus> &7You gave &a%amount% &7generator(s) of tier &a%tier% &7to &a%targetPlayer%"
generator-given-all: "&9GensPlus> &7You gave &a%amount% &7generator of tier &a%tier% &7to all players! (&a%count%&7)"
generator-received: "&9GensPlus> &7You received &a%amount% &7generator(s) of tier &a%tier%"

# [wands]
sell-wand-given: "&9GensPlus> &7You have been given a sell wand!"
sell-wand-received: "&9GensPlus> &7You have received a sell wand!"
wand-broke: "&cError> &7Your wand broke!"


================================================================================
File: .\src\main\resources\plugin.yml
================================================================================

name: GensPlus
version: '${project.version}'
main: xyz.arcadiadevs.gensplus.GensPlus
api-version: 1.13
authors:
  - Cuftica
  - OpenSource

depend:
  - Vault
  - ProtocolLib

softdepend:
  - Oraxen
  - Essentials
  - ItemsAdder
  - IridiumSkyblock
  - SuperiorSkyblock2
  - ASkyBlock
  - AcidIsland
  - BentoBox
  - HoloEasy

commands:
  gensplus:
    description: Main command
    usage: /gensplus
    aliases: [ gens, gp ]
  generators:
    description: List all generators in gui
    usage: /generators
  selldrops:
    description: Sell all drops in inventory
    usage: /selldrops


================================================================================
File: .\src\main\resources\data\block_data.json
================================================================================

[]


================================================================================
File: .\src\main\resources\data\player_data.json
================================================================================

[]


================================================================================
File: .\src\main\resources\data\wands_data.json
================================================================================

[]

